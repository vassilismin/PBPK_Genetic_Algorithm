{if(compartment %in% c("Blood" ))scale_y_continuous(trans='log10')}+
scale_color_manual("", values=cls)+
scale_linetype_manual("Models", values=ltp) +
theme(legend.key.size = unit(1.5, 'cm'),
legend.title = element_text(size=14),
legend.text = element_text(size=14),
axis.text = element_text(size = 14))
}
plots <- lapply(names(observations)[2:length(observations)],create.plots)
p1 <-  plots[[1]]
p2 <-  plots[[2]]
p3 <-  plots[[3]]
p4 <-  plots[[4]]
p5 <-  plots[[5]]
p6 <-  plots[[6]]
p7 <-  plots[[7]]
p8 <-  plots[[8]]
p9 <-  plots[[9]]
#gridExtra::grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8, p9,p10, nrow = 4)
#gridExtra::grid.arrange(p5,p6,p7,p8,nrow = 2)
#gridExtra::grid.arrange(p9,p10,nrow = 2)
ggpubr::ggarrange(p1, p2, p3, p4,p5,p6,p7,p8, p9, ncol=3, nrow=4,
common.legend = TRUE, legend="right")
obj.func2 <- function(par,phys_pars, position,  sample_time, inits, time_points, excretion_time_points){
params <- c(phys_pars, position, (par))
solution <- data.frame(ode(times = sample_time,  func = ode.func,
y = inits, parms = params,
method="lsodes",rtol = 1e-3, atol = 1e-3))
concentrations <- data.frame(solution$time, solution$C_li, solution$C_spl, solution$C_ki,
solution$C_lu, solution$C_ht, solution$Blood,
solution$C_bone,  solution$C_soft)
concentrations <- concentrations[solution$time %in%time_points, 2:dim(concentrations)[2]]
excr_solution <-  data.frame(solution$time, solution$Feces)
excr_solution <- excr_solution[solution$time %in% excretion_time_points,2]
observed <- list()
predicted <- list()
for (i in 1:length(concentrations)) {
observed[[i]] <- df[,i]
predicted[[i]] <- concentrations[,i]
}
observed[[i+1]] <- excretion #feces
predicted[[i+1]] <- excr_solution #feces
discrepancy <- fitness.metric(observed, predicted)
return(discrepancy)
}
#===================================
# Problem without constraints
#==================================
start.nl <- Sys.time()
res2 <- nloptr::nloptr( x0= exp(fitted_MAEP),
eval_f=obj.func2,
lb	= rep(1e-10, length(fitted_MAEP)),
ub = rep(Inf, length(fitted_MAEP)),
#eval_g_ineq = eval_g0,
opts = list("algorithm"="NLOPT_LN_COBYLA",
"xtol_rel"=1.0e-4, maxeval = -1),
phys_pars = phys_pars, position = position_MAEP, sample_time = sample_time,
inits = inits,
time_points = time_points,
excretion_time_points =  excretion_time_points)
stop.nl <- Sys.time()
print("Time for NM was: ")
print(stop.nm - start.nm)
print(paste0("with OF value: ", nm_optimizer_MAEP$value))
print("Time for NL was: ")
print(stop.nl - start.nl)
print(paste0("with OF value: ", res2$objective))
res2
start.nl <- Sys.time()
res2 <- nloptr::nloptr( x0= exp(fitted_MAEP),
eval_f=obj.func2,
lb	= rep(1e-100, length(fitted_MAEP)),
ub = rep(Inf, length(fitted_MAEP)),
#eval_g_ineq = eval_g0,
opts = list("algorithm"="NLOPT_LN_COBYLA",
"xtol_rel"=1.0e-4, maxeval = -1),
phys_pars = phys_pars, position = position_MAEP, sample_time = sample_time,
inits = inits,
time_points = time_points,
excretion_time_points =  excretion_time_points)
stop.nl <- Sys.time()
res2
phys_pars
par = params_MAEP
par = log(params_MAEP)
params <- c(phys_pars, position, exp(par))
solution <- data.frame(ode(times = sample_time,  func = ode.func,
y = inits, parms = params,
method="lsodes",rtol = 1e-3, atol = 1e-3))
concentrations <- data.frame(solution$time, solution$C_li, solution$C_spl, solution$C_ki,
solution$C_lu, solution$C_ht, solution$Blood,
solution$C_bone,  solution$C_soft)
concentrations <- concentrations[solution$time %in%time_points, 2:dim(concentrations)[2]]
position = position_MAEP
params <- c(phys_pars, position, exp(par))
solution <- data.frame(ode(times = sample_time,  func = ode.func,
y = inits, parms = params,
method="lsodes",rtol = 1e-3, atol = 1e-3))
concentrations <- data.frame(solution$time, solution$C_li, solution$C_spl, solution$C_ki,
solution$C_lu, solution$C_ht, solution$Blood,
solution$C_bone,  solution$C_soft)
concentrations <- concentrations[solution$time %in%time_points, 2:dim(concentrations)[2]]
concentrations
sum(concentrations - 2)
rest <- function(par,phys_pars, position,  sample_time, inits,
time_points, excretion_time_points){
params <- c(phys_pars, position, exp(par))
solution <- data.frame(ode(times = sample_time,  func = ode.func,
y = inits, parms = params,
method="lsodes",rtol = 1e-3, atol = 1e-3))
concentrations <- data.frame(solution$time, solution$C_li, solution$C_spl, solution$C_ki,
solution$C_lu, solution$C_ht, solution$Blood,
solution$C_bone,  solution$C_soft)
concentrations <- concentrations[solution$time %in%time_points, 2:dim(concentrations)[2]]
return(sum(concentrations - 2.1))
}
eval_g_ineq <- function(par,phys_pars, position,  sample_time, inits,
time_points, excretion_time_points){
params <- c(phys_pars, position, exp(par))
solution <- data.frame(ode(times = sample_time,  func = ode.func,
y = inits, parms = params,
method="lsodes",rtol = 1e-3, atol = 1e-3))
concentrations <- data.frame(solution$time, solution$C_li, solution$C_spl, solution$C_ki,
solution$C_lu, solution$C_ht, solution$Blood,
solution$C_bone,  solution$C_soft)
concentrations <- concentrations[solution$time %in%time_points, 2:dim(concentrations)[2]]
const <- c(sum(concentrations[,1] - 2.1) ,
sum(concentrations[,2] - 2.1),
sum(concentrations[,3] - 2.1),
sum(concentrations[,4] - 2.1))
return(const)
}
#===================================
# Problem without constraints
#==================================
opts <- list( "algorithm"
= "NLOPT_GN_ISRES",
"xtol_rel"
= 1.0e-4,
"maxeval"= 1000,
"tol_constraints_ineq" = rep(1, 5 ))
start.nl <- Sys.time()
res2 <- nloptr::nloptr( x0= fitted_MAEP,
eval_f=obj.func2,
lb	= rep(-20, length(fitted_MAEP)),
ub = rep(20, length(fitted_MAEP)),
eval_g_ineq = eval_g_ineq,
opts = opts,
phys_pars = phys_pars, position = position_MAEP, sample_time = sample_time,
inits = inits,
time_points = time_points,
excretion_time_points =  excretion_time_points)
stop.nl <- Sys.time()
fitted_MAEP
obj.func2 <- function(par,phys_pars, position,  sample_time, inits, time_points, excretion_time_points){
params <- c(phys_pars, position, exp(par))
solution <- data.frame(ode(times = sample_time,  func = ode.func,
y = inits, parms = params,
method="lsodes",rtol = 1e-3, atol = 1e-3))
concentrations <- data.frame(solution$time, solution$C_li, solution$C_spl, solution$C_ki,
solution$C_lu, solution$C_ht, solution$Blood,
solution$C_bone,  solution$C_soft)
concentrations <- concentrations[solution$time %in%time_points, 2:dim(concentrations)[2]]
excr_solution <-  data.frame(solution$time, solution$Feces)
excr_solution <- excr_solution[solution$time %in% excretion_time_points,2]
observed <- list()
predicted <- list()
for (i in 1:length(concentrations)) {
observed[[i]] <- df[,i]
predicted[[i]] <- concentrations[,i]
}
observed[[i+1]] <- excretion #feces
predicted[[i+1]] <- excr_solution #feces
discrepancy <- fitness.metric(observed, predicted)
return(discrepancy)
}
eval_g_ineq <- function(par,phys_pars, position,  sample_time, inits,
time_points, excretion_time_points){
params <- c(phys_pars, position, exp(par))
solution <- data.frame(ode(times = sample_time,  func = ode.func,
y = inits, parms = params,
method="lsodes",rtol = 1e-3, atol = 1e-3))
concentrations <- data.frame(solution$time, solution$C_li, solution$C_spl, solution$C_ki,
solution$C_lu, solution$C_ht, solution$Blood,
solution$C_bone,  solution$C_soft)
concentrations <- concentrations[solution$time %in%time_points, 2:dim(concentrations)[2]]
const <- c(sum(concentrations[,1] - 2.1) ,
sum(concentrations[,2] - 2.1),
sum(concentrations[,3] - 2.1),
sum(concentrations[,4] - 2.1))
return(const)
}
#===================================
# Problem without constraints
#==================================
opts <- list( "algorithm"
= "NLOPT_GN_ISRES",
"xtol_rel"
= 1.0e-4,
"maxeval"= 1000,
"tol_constraints_ineq" = rep(1, 5 ))
start.nl <- Sys.time()
res2 <- nloptr::nloptr( x0= fitted_MAEP,
eval_f=obj.func2,
lb	= rep(-20, length(fitted_MAEP)),
ub = rep(20, length(fitted_MAEP)),
eval_g_ineq = eval_g_ineq,
opts = opts,
phys_pars = phys_pars, position = position_MAEP, sample_time = sample_time,
inits = inits,
time_points = time_points,
excretion_time_points =  excretion_time_points)
stop.nl <- Sys.time()
#===================================
# Problem without constraints
#==================================
opts <- list( "algorithm"
= "NLOPT_GN_ISRES",
"xtol_rel"
= 1.0e-4,
"maxeval"= 1000,
"tol_constraints_ineq" = rep(1, 4 ))
start.nl <- Sys.time()
res2 <- nloptr::nloptr( x0= fitted_MAEP,
eval_f = obj.func2,
lb	= rep(-20, length(fitted_MAEP)),
ub = rep(20, length(fitted_MAEP)),
eval_g_ineq = eval_g_ineq,
opts = opts,
phys_pars = phys_pars, position = position_MAEP, sample_time = sample_time,
inits = inits,
time_points = time_points,
excretion_time_points =  excretion_time_points)
stop.nl <- Sys.time()
print("Time for NM was: ")
print(stop.nm - start.nm)
print(paste0("with OF value: ", nm_optimizer_MAEP$value))
print("Time for NL was: ")
print(stop.nl - start.nl)
print(paste0("with OF value: ", res2$objective))
start.nl <- Sys.time()
res2 <- nloptr::nloptr( x0= fitted_MAEP,
eval_f = obj.func2,
lb	= rep(-20, length(fitted_MAEP)),
ub = rep(20, length(fitted_MAEP)),
#  eval_g_ineq = eval_g_ineq,
opts = opts,
phys_pars = phys_pars, position = position_MAEP, sample_time = sample_time,
inits = inits,
time_points = time_points,
excretion_time_points =  excretion_time_points)
stop.nl <- Sys.time()
obj.func2 <- function(par,phys_pars, position,  sample_time, inits, time_points, excretion_time_points){
params <- c(phys_pars, position, exp(par))
solution <- data.frame(ode(times = sample_time,  func = ode.func,
y = inits, parms = params,
method="lsodes",rtol = 1e-3, atol = 1e-3))
concentrations <- data.frame(solution$time, solution$C_li, solution$C_spl, solution$C_ki,
solution$C_lu, solution$C_ht, solution$Blood,
solution$C_bone,  solution$C_soft)
concentrations <- concentrations[solution$time %in%time_points, 2:dim(concentrations)[2]]
excr_solution <-  data.frame(solution$time, solution$Feces)
excr_solution <- excr_solution[solution$time %in% excretion_time_points,2]
observed <- list()
predicted <- list()
for (i in 1:length(concentrations)) {
observed[[i]] <- df[,i]
predicted[[i]] <- concentrations[,i]
}
observed[[i+1]] <- excretion #feces
predicted[[i+1]] <- excr_solution #feces
discrepancy <- fitness.metric(observed, predicted)
return(discrepancy)
}
eval_g_ineq <- function(par,phys_pars, position,  sample_time, inits,
time_points, excretion_time_points){
params <- c(phys_pars, position, exp(par))
solution <- data.frame(ode(times = sample_time,  func = ode.func,
y = inits, parms = params,
method="lsodes",rtol = 1e-3, atol = 1e-3))
concentrations <- data.frame(solution$time, solution$C_li, solution$C_spl, solution$C_ki,
solution$C_lu, solution$C_ht, solution$Blood,
solution$C_bone,  solution$C_soft)
concentrations <- concentrations[solution$time %in%time_points, 2:dim(concentrations)[2]]
const <- c(sum(concentrations[,1] - 2.1) ,
sum(concentrations[,2] - 2.1),
sum(concentrations[,3] - 2.1),
sum(concentrations[,4] - 2.1))
return(const)
}
params <- c(phys_pars, position_MAEP, exp(res2$solution))
solution <- data.frame(ode(times = sample_time,  func = ode.func,
y = inits, parms = params,
method="bdf",rtol = 1e-5, atol = 1e-5))
solution_MAEP <- data.frame(solution$time, solution$C_li, solution$C_spl, solution$C_ki,
solution$C_lu, solution$C_ht, solution$Blood,
solution$C_bone,  solution$C_soft, solution$Feces)
names(solution_MAEP) <- c("Time",  "Liver",  "Spleen","Kidneys","Lungs","Heart","Blood","Bone", "RoB", "Feces")
# Create a single data frame to hold the observation data
observations <- data.frame( Time =c(1,4,24, 7*24, 28*24), df, c(NA,NA,excretion))
names(observations) <- c("Time",  "Liver",  "Spleen","Kidneys","Lungs","Heart","Blood","Bone", "RoB", "Feces")
#####################
#   Metrics  ########
######################
# Function to estimate the percentage of percent of model-predicted concentrations
# falling within twofold of the corresponding observed concentrations
two.fold <- function(predictions, observations, times=NULL){
y_obs <- unlist(observations)
y_pred <- unlist(predictions)
# Total number of observations
N<- length(y_obs)
# Counter for counting how many observations lie within two fold from the data
counter <- 0
for ( i in 1:N){
if ((y_pred[i]<=2*y_obs[i]) & (y_pred[i]>=0.5*y_obs[i])){
counter <- counter + 1
}
}
twofold_percentage <- (counter/N)*100
return(twofold_percentage)
}
#  absolute average fold error
AAFE <- function(predictions, observations, times=NULL){
y_obs <- unlist(observations)
y_pred <- unlist(predictions)
# Total number of observations
N<- length(y_obs)
log_ratio <- rep(NA, N)
for ( i in 1:N){
log_ratio[i] <- abs(log((y_pred[i]/y_obs[i]), base = 10))
}
aafe <- 10^(sum(log_ratio)/N)
return(aafe)
}
#  R-squared between predictions and observations
r.squared <- function(predictions, observations, times=NULL){
y_pred <- unlist(predictions)
y_obs <- unlist(observations)
lm.model <- lm(y_obs~y_pred)
r_squared <- summary(lm.model)$r.squared
return(r_squared)
}
#  Root-mean-square deviation
rmsd <- function(predictions, observations, times=NULL){
y_obs <- unlist(observations)
y_pred <- unlist(predictions)
# Total number of observations
N<- length(y_obs)
summation <- 0
for ( i in 1:N){
summation <- summation + (y_obs[i]-y_pred[i])^2
}
rmsd <- sqrt(summation/N)
return(rmsd)
}
pbpk.index <- function(observed, predicted, comp.names =NULL){
# Check if the user provided the correct input format
if (!is.list(observed) || !is.list(predicted)){
stop(" The observations and predictions must be lists")
}
# Check if the user provided equal length lists
if (length(observed) != length(predicted)){
stop(" The observations and predictions must have the same compartments")
}
Ncomp <- length(observed) # Number of compartments
I <- rep(NA, Ncomp) # Compartment discrepancy index
N_obs <- rep(NA, Ncomp) #Number of observations per compartment
#loop over the compartments
for (i in 1:Ncomp){
et <- 0 # errors
Et <-0  # experimental
N <- length(observed[[i]]) # number of observations for compartment i
# Check if observations and predictions have equal length
if(N != length(predicted[[i]])){
stop(paste0("Compartment ",i," had different length in the observations and predictions"))
}
N_obs[i] <- N # populate tne N_obs vector
for (j in 1:N){
# sum of absolute squared errors (error = observed - predicted)
et <- et + (abs(observed[[i]][j] - predicted[[i]][j]))^2
# Sum of squared observed values
Et <- Et + (observed[[i]][j])^2
}
# root mean square of the absolute error
RMet2 <-sqrt(et/N)
# root mean of the square of observed values
RMEt2 <- sqrt(Et/N)
I[i] <- RMet2/RMEt2
}
# Total number of observations
Ntot <- sum(N_obs)
# Initialise the consolidated discrepancy index
Ic <-0
for (i in 1:Ncomp){
Ic <- Ic +  I[i]* N_obs[i]/Ntot
}
# Name the list of compartment discrepancy indices
if ( !is.null(comp.names)){
names(I) <- comp.names
}else if (!is.null(names(observed))){
names(I) <- names(observed)
} else if (!is.null(names(predicted)) && is.null(comp.names) ){
names(I) <- names(predicted)
}
return(Ic)
#return(list(Total_index = Ic, Compartment_index= I))
}
metric.print <- function(x){
solution <- x
concentrations <- solution[solution$Time %in% time_points, 2:(dim(solution)[2]-2)]
excr_solution <-  data.frame(solution$Time, solution$Feces)
excr_solution <- excr_solution[solution$Time %in% excretion_time_points, 2]
observed <- list()
predicted <- list()
for (i in 1:(length(concentrations))) {
observed[[i]] <- df[,i]
predicted[[i]] <- concentrations[,i]
}
observed[[i+1]] <- excretion #feces
predicted[[i+1]] <- excr_solution #feces
print(paste0("PBPK index is: ", pbpk.index(observed, predicted)))
print(paste0("PBPK index is: ", r.squared(observed, predicted)))
print(paste0("PBPK index is: ", AAFE(observed, predicted)))
print(paste0("PBPK index is: ",rmsd(observed, predicted)))
print(paste0("PBPK index is: ", two.fold(observed, predicted)))
}
metric.print(solution_MAEP)
#####################
#    PLOTS  ########
######################
library(ggplot2)
# Defining the linetype and colour of each curve
ltp <- c( "Predictions" = "solid" )
cls <-  c("Predictions" ="#000000", "Observations" = "#D55E00")
create.plots <- function(compartment){
excreta <- compartment %in% c("Feces")
ggplot(data = solution_MAEP)+
geom_line( aes_string(x= "Time", y= rlang::expr(!!compartment),
color = '"Predictions"',linetype = '"Predictions"'),  size=1.5,alpha = 0.7) +
geom_point(data=observations, aes_string(x="Time", y= rlang::expr(!!compartment),
color='"Observations"'), size=4)+
labs(title = rlang::expr(!!compartment),
y = ifelse(excreta,"TiO2 (ug)","TiO2 (ug/g tissue)" ),
x = "Time (hours)")+
theme(plot.title = element_text(hjust = 0.5))+
{if(compartment %in% c("Blood" ))scale_y_continuous(trans='log10')}+
scale_color_manual("", values=cls)+
scale_linetype_manual("Models", values=ltp) +
theme(legend.key.size = unit(1.5, 'cm'),
legend.title = element_text(size=14),
legend.text = element_text(size=14),
axis.text = element_text(size = 14))
}
plots <- lapply(names(observations)[2:length(observations)],create.plots)
p1 <-  plots[[1]]
p2 <-  plots[[2]]
p3 <-  plots[[3]]
p4 <-  plots[[4]]
p5 <-  plots[[5]]
p6 <-  plots[[6]]
p7 <-  plots[[7]]
p8 <-  plots[[8]]
p9 <-  plots[[9]]
#gridExtra::grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8, p9,p10, nrow = 4)
#gridExtra::grid.arrange(p5,p6,p7,p8,nrow = 2)
#gridExtra::grid.arrange(p9,p10,nrow = 2)
ggpubr::ggarrange(p1, p2, p3, p4,p5,p6,p7,p8, p9, ncol=3, nrow=4,
common.legend = TRUE, legend="right")
#===================================
# Problem without constraints
#==================================
opts <- list( "algorithm"
= "NLOPT_GN_ISRES",
"xtol_rel"
= 1.0e-4,
"maxeval"= -1)
start.nl <- Sys.time()
res2 <- nloptr::nloptr( x0= fitted_MAEP,
eval_f = obj.func2,
lb	= rep(-20, length(fitted_MAEP)),
ub = rep(20, length(fitted_MAEP)),
#  eval_g_ineq = eval_g_ineq,
opts = opts,
phys_pars = phys_pars, position = position_MAEP, sample_time = sample_time,
inits = inits,
time_points = time_points,
excretion_time_points =  excretion_time_points)
stop.nl <- Sys.time()
#==================================
opts <- list( "algorithm"
= "NLOPT_GN_ISRES",
"xtol_rel"
= 1.0e-4,
"maxeval"= -1)
start.nl <- Sys.time()
res2 <- nloptr::nloptr( x0= fitted_MAEP,
eval_f = obj.func2,
lb	= rep(-20, length(fitted_MAEP)),
ub = rep(20, length(fitted_MAEP)),
eval_g_ineq = eval_g_ineq,
opts = opts,
phys_pars = phys_pars, position = position_MAEP, sample_time = sample_time,
inits = inits,
time_points = time_points,
excretion_time_points =  excretion_time_points)
stop.nl <- Sys.time()
print("Time for NM was: ")
print(stop.nm - start.nm)
print(paste0("with OF value: ", nm_optimizer_MAEP$value))
print("Time for NL was: ")
print(stop.nl - start.nl)
print(paste0("with OF value: ", res2$objective))
