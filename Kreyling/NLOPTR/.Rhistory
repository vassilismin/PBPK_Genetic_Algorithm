for ( i in 1:N){
log_ratio[i] <- abs(log((y_pred[i]/y_obs[i]), base = 10))
}
aafe <- 10^(sum(log_ratio)/N)
return(aafe)
}
#  R-squared between predictions and observations
r.squared <- function(predictions, observations, times=NULL){
y_pred <- unlist(predictions)
y_obs <- unlist(observations)
lm.model <- lm(y_obs~y_pred)
r_squared <- summary(lm.model)$r.squared
return(r_squared)
}
#  Root-mean-square deviation
rmsd <- function(predictions, observations, times=NULL){
y_obs <- unlist(observations)
y_pred <- unlist(predictions)
# Total number of observations
N<- length(y_obs)
summation <- 0
for ( i in 1:N){
summation <- summation + (y_obs[i]-y_pred[i])^2
}
rmsd <- sqrt(summation/N)
return(rmsd)
}
pbpk.index <- function(observed, predicted, comp.names =NULL){
# Check if the user provided the correct input format
if (!is.list(observed) || !is.list(predicted)){
stop(" The observations and predictions must be lists")
}
# Check if the user provided equal length lists
if (length(observed) != length(predicted)){
stop(" The observations and predictions must have the same compartments")
}
Ncomp <- length(observed) # Number of compartments
I <- rep(NA, Ncomp) # Compartment discrepancy index
N_obs <- rep(NA, Ncomp) #Number of observations per compartment
#loop over the compartments
for (i in 1:Ncomp){
et <- 0 # errors
Et <-0  # experimental
N <- length(observed[[i]]) # number of observations for compartment i
# Check if observations and predictions have equal length
if(N != length(predicted[[i]])){
stop(paste0("Compartment ",i," had different length in the observations and predictions"))
}
N_obs[i] <- N # populate tne N_obs vector
for (j in 1:N){
# sum of absolute squared errors (error = observed - predicted)
et <- et + (abs(observed[[i]][j] - predicted[[i]][j]))^2
# Sum of squared observed values
Et <- Et + (observed[[i]][j])^2
}
# root mean square of the absolute error
RMet2 <-sqrt(et/N)
# root mean of the square of observed values
RMEt2 <- sqrt(Et/N)
I[i] <- RMet2/RMEt2
}
# Total number of observations
Ntot <- sum(N_obs)
# Initialise the consolidated discrepancy index
Ic <-0
for (i in 1:Ncomp){
Ic <- Ic +  I[i]* N_obs[i]/Ntot
}
# Name the list of compartment discrepancy indices
if ( !is.null(comp.names)){
names(I) <- comp.names
}else if (!is.null(names(observed))){
names(I) <- names(observed)
} else if (!is.null(names(predicted)) && is.null(comp.names) ){
names(I) <- names(predicted)
}
return(Ic)
#return(list(Total_index = Ic, Compartment_index= I))
}
# Function for estimating all metrics
metric.print <- function(predictions, observations ){
concentrations <- predictions[predictions$Time %in% observations$Time, ]
observed <- list()
predicted <- list()
for (i in 1:(length(concentrations))) {
observed[[i]] <- observations[,i]
predicted[[i]] <- concentrations[,i]
}
print(paste0("pbpk index of model is: ", pbpk.index(observed, predicted)))
print(paste0("R-squared of model is: ", r.squared(observed, predicted)))
print(paste0("AAFE  of model is: ", AAFE(observed, predicted)))
print(paste0("RMSD of model is ", rmsd(observed, predicted)))
print(paste0("2-fold % of model is: ", two.fold(observed, predicted)))
print(paste0("PBKOF of model is: ", PBKOF(observed, predicted)))
}
metric.print(solution_MANG)
View(observations)
metric.print(solution_MANG, observations)
solution_MANG
observations
View(solution_MANG)
predictions <- solution_MANG
concentrations <- predictions[predictions$Time %in% observations$Time, ]
concentrations
predictions
observations$Time
predictions$Time
solution_MANG
# Create solutions for each model
parameters_MANG <- c(phys_pars, position_MANG, params_MANG)
sol_MANG <-  data.frame(deSolve::ode(times = sample_time,  func = ode.func,
y = inits, parms = parameters_MANG,
method="bdf",rtol = 1e-5, atol = 1e-5))
solution_MANG <- data.frame(sol_MANG$time, sol_MANG$C_li, sol_MANG$C_spl, sol_MANG$C_ki,
sol_MANG$C_lu, sol_MANG$C_ht, sol_MANG$Blood,
sol_MANG$C_bone,  sol_MANG$C_soft)
names(solution_MANG) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
###
parameters_MING <- c(phys_pars, position_MING, params_MING)
sol_MING <- data.frame(deSolve::ode(times = sample_time,  func = ode.func,
y = inits, parms = parameters_MING,
method="bdf",rtol = 1e-5, atol = 1e-5))
solution_MING <- data.frame(sol_MING$time, sol_MING$C_li, sol_MING$C_spl, sol_MING$C_ki,
sol_MING$C_lu, sol_MING$C_ht, sol_MING$Blood,
sol_MING$C_bone,  sol_MING$C_soft)
names(solution_MING) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
###
parameters_FPG <- c(phys_pars, position_FPG, params_FPG)
sol_FPG <- data.frame(deSolve::ode(times = sample_time,  func = ode.func,
y = inits, parms = parameters_FPG,
method="bdf",rtol = 1e-5, atol = 1e-5))
solution_FPG <- data.frame(sol_FPG$time, sol_FPG$C_li, sol_FPG$C_spl, sol_FPG$C_ki,
sol_FPG$C_lu, sol_FPG$C_ht, sol_FPG$Blood,
sol_FPG$C_bone,  sol_FPG$C_soft)
names(solution_FPG) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
###
parameters_PNG <- c(phys_pars, position_PNG, params_PNG)
sol_PNG <- data.frame(deSolve::ode(times = sample_time,  func = ode.func,
y = inits, parms = parameters_PNG,
method="bdf",rtol = 1e-5, atol = 1e-5))
solution_PNG <- data.frame(sol_PNG$time, sol_PNG$C_li, sol_PNG$C_spl, sol_PNG$C_ki,
sol_PNG$C_lu, sol_PNG$C_ht, sol_PNG$Blood,
sol_PNG$C_bone,  sol_PNG$C_soft)
names(solution_PNG) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
##
parameters_SPPCG <- c(phys_pars, position_SPPCG, params_SPPCG)
sol_SPPCG <- data.frame(deSolve::ode(times = sample_time,  func = ode.func,
y = inits, parms = parameters_SPPCG,
method="bdf",rtol = 1e-5, atol = 1e-5))
names(sol_SPPCG) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
solution_SPPCG <- data.frame(sol_SPPCG$time, sol_SPPCG$C_li, sol_SPPCG$C_spl, sol_SPPCG$C_ki,
sol_SPPCG$C_lu, sol_SPPCG$C_ht, sol_SPPCG$Blood,
sol_SPPCG$C_bone,  sol_SPPCG$C_soft)
# Create a single data frame to hold the observation data
observations <- data.frame( Time =c(1,4,24, 7*24, 28*24), df,  c(NA,NA,excretion))
names(observations) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
###########################################
#==========================================
#               Model Metrics             #
#==========================================
###########################################
#
#Function to estimate the percentage of percent of model-predicted concentrations
# falling within twofold of the corresponding observed concentrations
two.fold <- function(predictions, observations, times=NULL){
y_obs <- unlist(observations)
y_pred <- unlist(predictions)
# Total number of observations
N<- length(y_obs)
# Counter for counting how many observations lie within two fold from the data
counter <- 0
for ( i in 1:N){
if ((y_pred[i]<=2*y_obs[i]) & (y_pred[i]>=0.5*y_obs[i])){
counter <- counter + 1
}
}
twofold_percentage <- (counter/N)*100
return(twofold_percentage)
}
#  absolute average fold error
AAFE <- function(predictions, observations, times=NULL){
y_obs <- unlist(observations)
y_pred <- unlist(predictions)
# Total number of observations
N<- length(y_obs)
log_ratio <- rep(NA, N)
for ( i in 1:N){
log_ratio[i] <- abs(log((y_pred[i]/y_obs[i]), base = 10))
}
aafe <- 10^(sum(log_ratio)/N)
return(aafe)
}
#  R-squared between predictions and observations
r.squared <- function(predictions, observations, times=NULL){
y_pred <- unlist(predictions)
y_obs <- unlist(observations)
lm.model <- lm(y_obs~y_pred)
r_squared <- summary(lm.model)$r.squared
return(r_squared)
}
#  Root-mean-square deviation
rmsd <- function(predictions, observations, times=NULL){
y_obs <- unlist(observations)
y_pred <- unlist(predictions)
# Total number of observations
N<- length(y_obs)
summation <- 0
for ( i in 1:N){
summation <- summation + (y_obs[i]-y_pred[i])^2
}
rmsd <- sqrt(summation/N)
return(rmsd)
}
pbpk.index <- function(observed, predicted, comp.names =NULL){
# Check if the user provided the correct input format
if (!is.list(observed) || !is.list(predicted)){
stop(" The observations and predictions must be lists")
}
# Check if the user provided equal length lists
if (length(observed) != length(predicted)){
stop(" The observations and predictions must have the same compartments")
}
Ncomp <- length(observed) # Number of compartments
I <- rep(NA, Ncomp) # Compartment discrepancy index
N_obs <- rep(NA, Ncomp) #Number of observations per compartment
#loop over the compartments
for (i in 1:Ncomp){
et <- 0 # errors
Et <-0  # experimental
N <- length(observed[[i]]) # number of observations for compartment i
# Check if observations and predictions have equal length
if(N != length(predicted[[i]])){
stop(paste0("Compartment ",i," had different length in the observations and predictions"))
}
N_obs[i] <- N # populate tne N_obs vector
for (j in 1:N){
# sum of absolute squared errors (error = observed - predicted)
et <- et + (abs(observed[[i]][j] - predicted[[i]][j]))^2
# Sum of squared observed values
Et <- Et + (observed[[i]][j])^2
}
# root mean square of the absolute error
RMet2 <-sqrt(et/N)
# root mean of the square of observed values
RMEt2 <- sqrt(Et/N)
I[i] <- RMet2/RMEt2
}
# Total number of observations
Ntot <- sum(N_obs)
# Initialise the consolidated discrepancy index
Ic <-0
for (i in 1:Ncomp){
Ic <- Ic +  I[i]* N_obs[i]/Ntot
}
# Name the list of compartment discrepancy indices
if ( !is.null(comp.names)){
names(I) <- comp.names
}else if (!is.null(names(observed))){
names(I) <- names(observed)
} else if (!is.null(names(predicted)) && is.null(comp.names) ){
names(I) <- names(predicted)
}
return(Ic)
#return(list(Total_index = Ic, Compartment_index= I))
}
# Function for estimating all metrics
metric.print <- function(predictions, observations ){
concentrations <- predictions[predictions$Time %in% observations$Time, ]
observed <- list()
predicted <- list()
for (i in 1:(length(concentrations))) {
observed[[i]] <- observations[,i]
predicted[[i]] <- concentrations[,i]
}
print(paste0("pbpk index of model is: ", pbpk.index(observed, predicted)))
print(paste0("R-squared of model is: ", r.squared(observed, predicted)))
print(paste0("AAFE  of model is: ", AAFE(observed, predicted)))
print(paste0("RMSD of model is ", rmsd(observed, predicted)))
print(paste0("2-fold % of model is: ", two.fold(observed, predicted)))
print(paste0("PBKOF of model is: ", PBKOF(observed, predicted)))
}
metric.print(solution_MANG, observations)
metric.print(solution_MING, observations)
metric.print(solution_FPG, observations)
metric.print(solution_PNG, observations)
metric.print(solution_SPPCG, observations)
# Create solutions for each model
parameters_MANG <- c(phys_pars, position_MANG, params_MANG)
sol_MANG <-  data.frame(deSolve::ode(times = sample_time,  func = ode.func,
y = inits, parms = parameters_MANG,
method="bdf",rtol = 1e-5, atol = 1e-5))
solution_MANG <- data.frame(sol_MANG$time, sol_MANG$C_li, sol_MANG$C_spl, sol_MANG$C_ki,
sol_MANG$C_lu, sol_MANG$C_ht, sol_MANG$Blood,
sol_MANG$C_bone,  sol_MANG$C_soft, sol_MANG$Feces)
names(solution_MANG) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
###
parameters_MING <- c(phys_pars, position_MING, params_MING)
sol_MING <- data.frame(deSolve::ode(times = sample_time,  func = ode.func,
y = inits, parms = parameters_MING,
method="bdf",rtol = 1e-5, atol = 1e-5))
solution_MING <- data.frame(sol_MING$time, sol_MING$C_li, sol_MING$C_spl, sol_MING$C_ki,
sol_MING$C_lu, sol_MING$C_ht, sol_MING$Blood,
sol_MING$C_bone,  sol_MING$C_soft, sol_MING$Feces)
names(solution_MING) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
###
parameters_FPG <- c(phys_pars, position_FPG, params_FPG)
sol_FPG <- data.frame(deSolve::ode(times = sample_time,  func = ode.func,
y = inits, parms = parameters_FPG,
method="bdf",rtol = 1e-5, atol = 1e-5))
solution_FPG <- data.frame(sol_FPG$time, sol_FPG$C_li, sol_FPG$C_spl, sol_FPG$C_ki,
sol_FPG$C_lu, sol_FPG$C_ht, sol_FPG$Blood,
sol_FPG$C_bone,  sol_FPG$C_soft, sol_FPG$Feces)
names(solution_FPG) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
parameters_PNG <- c(phys_pars, position_PNG, params_PNG)
sol_PNG <- data.frame(deSolve::ode(times = sample_time,  func = ode.func,
y = inits, parms = parameters_PNG,
method="bdf",rtol = 1e-5, atol = 1e-5))
solution_PNG <- data.frame(sol_PNG$time, sol_PNG$C_li, sol_PNG$C_spl, sol_PNG$C_ki,
sol_PNG$C_lu, sol_PNG$C_ht, sol_PNG$Blood,
sol_PNG$C_bone,  sol_PNG$C_soft, sol_PNG$Feces )
names(solution_PNG) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
View(sol_SPPCG)
parameters_SPPCG <- c(phys_pars, position_SPPCG, params_SPPCG)
sol_SPPCG <- data.frame(deSolve::ode(times = sample_time,  func = ode.func,
y = inits, parms = parameters_SPPCG,
method="bdf",rtol = 1e-5, atol = 1e-5))
solution_SPPCG <- data.frame(sol_SPPCG$time, sol_SPPCG$C_li, sol_SPPCG$C_spl, sol_SPPCG$C_ki,
sol_SPPCG$C_lu, sol_SPPCG$C_ht, sol_SPPCG$Blood,
sol_SPPCG$C_bone,  sol_SPPCG$C_soft, sol_SPPCG$Feces)
names(sol_SPPCG) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
sol_SPPCG
parameters_SPPCG <- c(phys_pars, position_SPPCG, params_SPPCG)
sol_SPPCG <- data.frame(deSolve::ode(times = sample_time,  func = ode.func,
y = inits, parms = parameters_SPPCG,
method="bdf",rtol = 1e-5, atol = 1e-5))
sol_SPPCG
data.frame(sol_SPPCG$time, sol_SPPCG$C_li, sol_SPPCG$C_spl, sol_SPPCG$C_ki,
sol_SPPCG$C_lu, sol_SPPCG$C_ht, sol_SPPCG$Blood,
sol_SPPCG$C_bone,  sol_SPPCG$C_soft, sol_SPPCG$Feces)
names(sol_SPPCG) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
sol_SPPCG
solution_SPPCG <- data.frame(sol_SPPCG$time, sol_SPPCG$C_li, sol_SPPCG$C_spl, sol_SPPCG$C_ki,
sol_SPPCG$C_lu, sol_SPPCG$C_ht, sol_SPPCG$Blood,
sol_SPPCG$C_bone,  sol_SPPCG$C_soft, sol_SPPCG$Feces)
names(solution_SPPCG) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
parameters_SPPCG <- c(phys_pars, position_SPPCG, params_SPPCG)
sol_SPPCG <- data.frame(deSolve::ode(times = sample_time,  func = ode.func,
y = inits, parms = parameters_SPPCG,
method="bdf",rtol = 1e-5, atol = 1e-5))
solution_SPPCG <- data.frame(sol_SPPCG$time, sol_SPPCG$C_li, sol_SPPCG$C_spl, sol_SPPCG$C_ki,
sol_SPPCG$C_lu, sol_SPPCG$C_ht, sol_SPPCG$Blood,
sol_SPPCG$C_bone,  sol_SPPCG$C_soft, sol_SPPCG$Feces)
names(solution_SPPCG) <- c("Time", "Liver",  "Spleen",
"Kidneys", "Lungs", "Heart","Blood", "Bone",  "Rob","Feces")
solution_SPPCG
# Function for estimating all metrics
metric.print <- function(predictions, observations ){
concentrations <- predictions[predictions$Time %in% observations$Time, ]
observed <- list()
predicted <- list()
for (i in 1:(length(concentrations))) {
observed[[i]] <- observations[,i]
predicted[[i]] <- concentrations[,i]
}
print(paste0("pbpk index of model is: ", pbpk.index(observed, predicted)))
print(paste0("R-squared of model is: ", r.squared(observed, predicted)))
print(paste0("AAFE  of model is: ", AAFE(observed, predicted)))
print(paste0("RMSD of model is ", rmsd(observed, predicted)))
print(paste0("2-fold % of model is: ", two.fold(observed, predicted)))
print(paste0("PBKOF of model is: ", PBKOF(observed, predicted)))
}
metric.print(solution_MANG, observations)
View(predictions)
predictions <- solution_MANG
predictions[predictions$Time %in% observations$Time, ]
observations
concentrations
predictions
concentrations <- predictions[predictions$Time %in% observations$Time, ]
concentrations
names(concentrations)[i]
i = 1
names(concentrations)[i]
observations
i = 2
names(concentrations)[i]
# Function for estimating all metrics
metric.print <- function(predictions, observations ){
concentrations <- predictions[predictions$Time %in% observations$Time, ]
observed <- list()
predicted <- list()
for (i in 2:(length(concentrations))) {
if(names(concentrations)[i] == Feces){
observed[[i]] <- observations[,i]
predicted[[i]] <- concentrations[,i]
}else{
observed[[i]] <- observations[3:5,i]
predicted[[i]] <- concentrations[3:5,i]
}
}
print(paste0("pbpk index of model is: ", pbpk.index(observed, predicted)))
print(paste0("R-squared of model is: ", r.squared(observed, predicted)))
print(paste0("AAFE  of model is: ", AAFE(observed, predicted)))
print(paste0("RMSD of model is ", rmsd(observed, predicted)))
print(paste0("2-fold % of model is: ", two.fold(observed, predicted)))
print(paste0("PBKOF of model is: ", PBKOF(observed, predicted)))
}
metric.print(solution_MANG, observations)
# Function for estimating all metrics
metric.print <- function(predictions, observations ){
concentrations <- predictions[predictions$Time %in% observations$Time, ]
observed <- list()
predicted <- list()
for (i in 2:(length(concentrations))) {
if(names(concentrations)[i] == "Feces"){
observed[[i]] <- observations[,i]
predicted[[i]] <- concentrations[,i]
}else{
observed[[i]] <- observations[3:5,i]
predicted[[i]] <- concentrations[3:5,i]
}
}
print(paste0("pbpk index of model is: ", pbpk.index(observed, predicted)))
print(paste0("R-squared of model is: ", r.squared(observed, predicted)))
print(paste0("AAFE  of model is: ", AAFE(observed, predicted)))
print(paste0("RMSD of model is ", rmsd(observed, predicted)))
print(paste0("2-fold % of model is: ", two.fold(observed, predicted)))
print(paste0("PBKOF of model is: ", PBKOF(observed, predicted)))
}
metric.print(solution_MANG, observations)
View(solution_MANG)
predictions <- solution_MANG
concentrations <- predictions[predictions$Time %in% observations$Time, ]
observed <- list()
predicted <- list()
for (i in 2:(length(concentrations))) {
if(names(concentrations)[i] == "Feces"){
observed[[i]] <- observations[,i]
predicted[[i]] <- concentrations[,i]
}else{
observed[[i]] <- observations[3:5,i]
predicted[[i]] <- concentrations[3:5,i]
}
}
observed
concentrations <- predictions[predictions$Time %in% observations$Time, ]
observed <- list()
predicted <- list()
concentrations
for (i in 2:(length(concentrations))) {
if(names(concentrations)[i] == "Feces"){
observed[[i]] <- observations[3:5,i]
predicted[[i]] <- concentrations[3:5,i]
}else{
observed[[i]] <- observations[,i]
predicted[[i]] <- concentrations[,i]
}
}
observed
2:(length(concentrations))
observations[,2]
concentrations <- predictions[predictions$Time %in% observations$Time, ]
observed <- list()
predicted <- list()
for (i in 2:(length(concentrations))) {
if(names(concentrations)[i] == "Feces"){
observed[[i-1]] <- observations[3:5,i]
predicted[[i-1]] <- concentrations[3:5,i]
}else{
observed[[i-1]] <- observations[,i]
predicted[[i-1]] <- concentrations[,i]
}
}
observed
predicted
# Function for estimating all metrics
metric.print <- function(predictions, observations ){
concentrations <- predictions[predictions$Time %in% observations$Time, ]
observed <- list()
predicted <- list()
for (i in 2:(length(concentrations))) {
if(names(concentrations)[i] == "Feces"){
observed[[i-1]] <- observations[3:5,i]
predicted[[i-1]] <- concentrations[3:5,i]
}else{
observed[[i-1]] <- observations[,i]
predicted[[i-1]] <- concentrations[,i]
}
}
print(paste0("pbpk index of model is: ", pbpk.index(observed, predicted)))
print(paste0("R-squared of model is: ", r.squared(observed, predicted)))
print(paste0("AAFE  of model is: ", AAFE(observed, predicted)))
print(paste0("RMSD of model is ", rmsd(observed, predicted)))
print(paste0("2-fold % of model is: ", two.fold(observed, predicted)))
print(paste0("PBKOF of model is: ", PBKOF(observed, predicted)))
}
metric.print(solution_MANG, observations)
metric.print(solution_MING, observations)
metric.print(solution_FPG, observations)
