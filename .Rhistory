return(A)
})
}
#====================
#3. Matrix exponent
#====================
#--------------------------------------------------------------------------------------------------
# "Solve_exp_matrix()" is a function that solves the ODE system using the matrix "x" (which
# contains the coefficients of the system), "time" which is the desired time points to
# be calculated and "y_init" is the initial values of the state variables.
#--------------------------------------------------------------------------------------------------
solve_exp_matrix <- function(x, time, y_init, phys_pars){
with( as.list(phys_pars),{
if(!is.matrix(x)){
stop("x must be a NxN matrix")
}
if(!is.numeric(y_init)){
stop("y_init must be a numeric vector")
}
if(dim(x)[1] != dim(x)[2]){
stop("Matrix x must be NxN")
}
if(dim(x)[1] != length(y_init)){
stop("Dimension of y_init must be equal to dimension of matrix x")
}
y_t  <- matrix(data=NA, nrow = nrow(x), ncol = length(time))
colnames(y_t) <- as.character(time)
y_t[,1] <- y_init
for (t in 2:length(time)) {
solution_t <- expm::expm(x*time[t])%*%y_init
y_t[,t] <- solution_t
}
rownames(y_t) <- rownames(x)
y_t <- data.frame(t(y_t))
# Transform TiO2 masses to concentrations
concentrations <- cbind(time,
(y_t$M_ven + y_t$M_art + y_t$M_cap_ht + y_t$M_cap_lu +
y_t$M_cap_li+y_t$M_cap_spl+
y_t$M_cap_ki+ y_t$M_cap_git +
y_t$M_cap_bone + y_t$M_cap_rob)/V_blood,
y_t$M_ht/w_ht,
y_t$M_lu/w_lu,
y_t$M_li/w_li,
y_t$M_spl/w_spl,
y_t$M_ki/w_ki,
(y_t$M_git+y_t$M_lumen)/w_git,
y_t$M_bone/w_bone,
y_t$M_feces,
y_t$M_urine)
colnames(concentrations) <- c("Time","C_blood", "C_ht", "C_lu", "C_li",
"C_spl", "C_ki", "C_git", "C_bone", "Feces", "Urine")
#return(list(y_t, concentrations))
return(data.frame(concentrations))
})
}
#===============
#4. Improved fitness metric
#===============
############# Calculate PBPK indices #############
# fitness.metric function the returns the compartment and consolidated (Total) discrepancy index
# of a PBPK model, given some experimental data. It follows the paper of Krishnan et al.1995.
# observed: list of vectors containing the experimental data
# predictions: list of vectors containing the predicted data
# names of the compartments
fitness.metric <- function(observed, predicted, comp.names =NULL){
# Check if the user provided the correct input format
if (!is.list(observed) || !is.list(predicted)){
stop(" The observations and predictions must be lists")
}
# Check if the user provided equal length lists
if (length(observed) != length(predicted)){
stop(" The observations and predictions must have the same compartments")
}
Ncomp <- length(observed) # Number of compartments
I <- rep(NA, Ncomp) # Compartment discrepancy index
N_obs <- rep(NA, Ncomp) #Number of observations per compartment
#loop over the compartments
for (i in 1:Ncomp){
Et <- 0 #relative error with observations
St <- 0  #relative error with simulations
N <- length(observed[[i]]) # number of observations for compartment i
# Check if observations and predictions have equal length
if(N != length(predicted[[i]])){
stop(paste0("Compartment ",i," had different length in the observations and predictions"))
}
N_obs[i] <- N # populate the N_obs vector
for (j in 1:N){
# sum of relative squared errors (error = observed - predicted)
Et <- Et + ( abs(observed[[i]][j] - predicted[[i]][j])  / observed[[i]][j] )  ^2
St <- St + ( abs(observed[[i]][j] - predicted[[i]][j])  / predicted[[i]][j] )  ^2
}
# root mean of the square of observed values
RMEt <- sqrt(Et/N)
# root mean of the square of simulated values
RMSt <- sqrt( St/N)
I[i] <- (RMEt + RMSt)/2
}
# Total number of observations
Ntot <- sum(N_obs)
# Initialise the consolidated discrepancy index
Ic <-0
for (i in 1:Ncomp){
# Give weight to compartments with more observations (more information)
Ic <- Ic +  I[i]* N_obs[i]/Ntot
}
# Name the list of compartment discrepancy indices
if ( !is.null(comp.names)){
names(I) <- comp.names
}else if (!is.null(names(observed))){
names(I) <- names(observed)
} else if (!is.null(names(predicted)) && is.null(comp.names) ){
names(I) <- names(predicted)
}
return(Ic)
#return(list(Total_index = Ic, Compartment_index= I))
}
#======================
#5. Objective function
#======================
obj.func <- function(params, ...){
dots <- list(...)
with(as.list(dots),{
# Create the matrix of the system
A <- create_ODE_matrix(phys_pars = phys_pars, fit_pars =exp(params),  position = position )
# Solve the ODE system using the exponential matrix method
solution <-  solve_exp_matrix(x = A, time = sample_time, y_init = y_init,phys_pars = phys_pars )
concentrations <- solution[solution$Time %in% time_points, 2:(dim(solution)[2]-2)]
excr_solution <-  data.frame(solution$Time, solution$Feces, solution$Urine)
excr_solution <- excr_solution[solution$Time %in% excretion_time_points, c(2:3)]
observed <- list()
predicted <- list()
for (i in 1:(length(concentrations))) {
observed[[i]] <- df[,i]
predicted[[i]] <- concentrations[,i]
}
observed[[i+1]] <- excretion[,1] #feces
observed[[i+2]] <- excretion[,2] #urine
predicted[[i+1]] <- excr_solution[,1] #feces
predicted[[i+2]] <- excr_solution[,2] #urine
discrepancy <- fitness.metric(observed, predicted)
return(discrepancy)
})
}
#==================
#6.Binary mapping
#==================
# Function for mapping the binary number to integer
# Since with 4 digits numbers from 0-15 can be mapped and here we have 8
# different compartments, every two integers correspond to one compartment
bin2int <- function(bin_seq){
int <- GA::binary2decimal(bin_seq)
if(int == 0 || int == 1){
return(1)
}else if(int == 2 || int == 3){
return(2)
}else if(int == 4 || int == 5){
return(3)
}else if(int == 6 || int == 7){
return(4)
}else if(int == 8 || int == 9){
return(5)
}else if(int == 10 || int == 11){
return(6)
}else if(int == 12 || int == 13){
return(7)
}else if(int == 14 || int == 15){
return(8)
}
}
#=============================
#7. Convert binary to grouping
#=============================
# Function for converting binary into integer (from )
decode_ga <- function(binary_num)
{
# Convert binary encoding to gray encoding to avoid the Hamming cliff problem
gray_num <- GA::gray2binary(binary_num)
gray_num <- binary_num
#Four digit binary encodes up to 15, if we are past 13, assign the value 13
# Partition coefficient grouping
P1 <-bin2int(gray_num[1:4])
P2 <-bin2int(gray_num[5:8])
P3 <-bin2int(gray_num[9:12])
P4 <-bin2int(gray_num[13:16])
P5 <-bin2int(gray_num[17:20])
P6 <-bin2int(gray_num[21:24])
P7 <-bin2int(gray_num[25:28])
P8 <-bin2int(gray_num[29:32])
# Permeability coefficient grouping
X1 <-bin2int(gray_num[33:36])
X2 <-bin2int(gray_num[37:40])
X3 <-bin2int(gray_num[41:44])
X4 <-bin2int(gray_num[45:48])
X5 <-bin2int(gray_num[49:52])
X6 <-bin2int(gray_num[53:56])
X7 <-bin2int(gray_num[57:60])
X8 <-bin2int(gray_num[61:64])
out <- structure(c(P1,P2,P3,P4,P5,P6,P7,P8, X1,X2,X3,X4,X5,
X6,X7,X8), names = c("P1","P2","P3","P4",
"P5","P6", "P7", "P8", "X1",
"X2", "X3", "X4", "X5", "X6", "X7", "X8"))
return(out)
}
#=============================
#8. Create position
#=============================
# Function for creating the position from which to draw each param from the fitted params vector
create.position <- function(grouping){
#---------------------------
# Define fitting parameters
#---------------------------
N_p <-8 #   Number of partition coefficients
N_x <- 8#   Number of permeability coefficients
# Define size of P and X groups
P_groups <- length(unique(grouping[1:N_p]))  # sample size
X_groups <- length(unique(grouping[(N_p+1):(N_p+N_x)]))  # sample size
# set.seed(0)
# Initilise parameter values
fitted <- rep(NA, P_groups+X_groups+3)
# Initialise naming vectors
pnames <- rep(NA, P_groups)
xnames <- rep(NA, X_groups)
#Define names for P and X groups
for (i in 1:P_groups){
pnames[i] <- paste0("P", as.character(unique(grouping[1:N_p])[i]))
}
for (j in 1:X_groups){
xnames[j] <- paste0("X", as.character(unique(grouping[(N_p+1):(N_p+N_x)])[j]))
}
# Define the total parameter vector names
names(fitted) <- c(pnames, xnames,"CLE_f", "CLE_u", "CLE_h")
# Variable for keeping which value in the fitted params vector corresponds to each coefficient
position = rep(NA, length(grouping))
for (i in 1:(length(position))){
if(i<=8){
position[i] <- which(names(fitted) == paste0("P", as.character(grouping[i])))
}else{
position[i] <- which(names(fitted) == paste0("X", as.character(grouping[i])))
}
}
fitted[] <- c(log(exp(runif(P_groups, 3,6))),log(exp(runif(X_groups+3, -3,1))))
return(list("position"=position,"fitted"=fitted))
}
#===============
# Load data
#===============
setwd("C:/Users/ptsir/Documents/GitHub/PBPK_Genetic_Algorithm")
dose_kg <- 10 # mg/kg rat body
mass <- 250 # g
dose <- dose_kg*mass/1000 # mg TiO2
# Load raw data from paper Xie et al.2011
df <- openxlsx::read.xlsx("TiO2_iv_rat.xlsx", sheet = 1, colNames = T, rowNames = T) # TiO2 NPs %ID/g of tissue  (Table 1)
excretion <- openxlsx::read.xlsx("Cummulative_Excretion.xlsx", sheet = 2, colNames = T, rowNames = F) # accumulated excretory rate, expressed as %ID
excretion_time <- round(excretion[,1])*24 # hours
excretion <- excretion[,c(2:3)]
# Transform to (mg of NPs)/(g of tissue)
df <- (df/100)*dose
df$Intestine <- df$Intestine +df$Stomach
colnames(df)[which(names(df)=="Intestine")] <- "Git"
df <- subset(df, select = -c(Stomach, Brain))
df[5,1] <- 1e-05
excretion <- (excretion/100)*dose
### Important!!! each compartment has a specific index vectors Tissue_fractions, Regional_flow_fractions, Capillary_fractions and cannot be changed
# The index of each compartment:
#Rest of Body (rob) --> 1
#Heart (ht) --> 2
#Kidneys (ki) --> 3
#Brain (br) --> 4
#Spleen (spl) --> 5
#Lungs (lu) --> 6
#Liver (li) --> 7
#Uterus (ut) --> 8
#Bone (bone) --> 9
#Adipose (ad) --> 10
#Skin (skin) --> 11
#Muscles (mu) --> 12
#Gastrointestinal track (GIT) --> 13
#### If any of these compartments don not exist in pbpk, just give it the value NA in compartments vector, example: "Heart" = NA and it will remove it
#### from the equilibriums and the corresponding V_tis, V_cap, Q will be equal to NA.
compartments <- list( "RoB"="RoB","Heart"="Heart", "Kidneys"="Kidneys", "Brain"= NA, "Spleen"="Spleen",
"Lungs"="Lungs", "Liver"="Liver", "Uterus"=NA, "Bone"="Bone", "Adipose"=NA, "Skin"=NA, "Muscles"=NA, "GIT"="GIT") #used as input in function, compartments that are used in pbpk
# Nelder-Mead from dfoptim package
y_init <- c(dose, rep(0,20))
time_points <- c(1,3,7, 15, 30)*24 # hours
excretion_time_points <- excretion_time
sample_time <- seq(0, 30*24, 1)
# Initialise vector of physiological parameters
phys_pars <- create.params(compartments,mass)
load("C:/Users/ptsir/Documents/GitHub/PBPK_Genetic_Algorithm/ga_bin_results_new_structure.RData")
# Create the parameter grouping for the max and ga problems
grouping_max <- c(1:8, 1:8)
grouping_min <- c(rep(1,8), rep(1,8))
grouping_ga_newFitness <- decode_ga(GA_results@solution[1,])
# Create the position vector to match the ODE parameters with the fitted parameter values
position_max <- create.position(grouping_max)$position
position_min <- create.position(grouping_min)$position
position_ga_newFitness <- create.position(grouping_ga_newFitness)$position
# Initialise fitted
fitted_max <-  create.position(grouping_max)$fitted
fitted_min <-  create.position(grouping_min)$fitted
fitted_ga_newFitness <-  create.position(grouping_ga_newFitness)$fitted
MAX <- 800
nm_optimizer_max<- dfoptim::nmk(par = fitted_max, fn = obj.func,
control = list(maxfeval=MAX, trace=T), y_init = y_init,
time_points = time_points,
excretion_time_points =  excretion_time_points,
sample_time = sample_time,
phys_pars = phys_pars,
position = position_max )
max_params<- exp(nm_optimizer_max$par)
nm_optimizer_min<- dfoptim::nmk(par = fitted_min, fn = obj.func,
control = list(maxfeval=MAX, trace=T), y_init = y_init,
time_points = time_points,
excretion_time_points =  excretion_time_points,
sample_time = sample_time,
phys_pars = phys_pars,
position = position_min )
min_params<- exp(nm_optimizer_min$par)
nm_optimizer_ga_newFitness<- dfoptim::nmk(par = fitted_ga_newFitness, fn = obj.func,
control = list(maxfeval=MAX, trace=T), y_init = y_init,
time_points = time_points,
excretion_time_points =  excretion_time_points,
sample_time = sample_time,
phys_pars = phys_pars,
position = position_ga_newFitness )
ga_newFitness_params<- exp(nm_optimizer_ga_newFitness$par)
# Create the matrix of the system
A_max <- create_ODE_matrix(phys_pars = phys_pars, fit_pars = max_params,  position = position_max)
A_min <- create_ODE_matrix(phys_pars = phys_pars, fit_pars = min_params,  position = position_min)
A_ga_newFitness <- create_ODE_matrix(phys_pars = phys_pars, fit_pars = ga_newFitness_params,
position = position_ga_newFitness )
# Solve the ODE system using the exponential matrix method
solution_max <-  as.data.frame(solve_exp_matrix(x = A_max, time = sample_time,
y_init = y_init,phys_pars = phys_pars ))
names(solution_max) <- c("Time", "Blood", "Heart", "Lungs", "Liver",  "Spleen",
"Kidneys","Git", "Bone",  "Feces", "Urine")
solution_min <-  as.data.frame(solve_exp_matrix(x = A_min, time = sample_time,
y_init = y_init,phys_pars = phys_pars ))
names(solution_min) <- c("Time", "Blood", "Heart", "Lungs", "Liver",  "Spleen",
"Kidneys","Git", "Bone",  "Feces", "Urine")
solution_ga_newFitness <-  as.data.frame(solve_exp_matrix(x = A_ga_newFitness, time = sample_time,
y_init = y_init,phys_pars = phys_pars ))
names(solution_ga_newFitness) <- c("Time","Blood", "Heart", "Lungs", "Liver", "Spleen",
"Kidneys","Git", "Bone",  "Feces", "Urine")
# Create a single data frame to hold the observation data
observations <- data.frame( Time =c(24,  72, 168, 360, 720), excretion, df)
library(ggplot2)
create.plots <- function(compartment){
excreta <- compartment %in% c("Feces", "Urine")
ggplot(data = solution_max)+
geom_line( aes_string(x= "Time", y= rlang::expr(!!compartment), colour=shQuote("Max params")),
size=1.5) +
geom_line( aes_string(x= "Time", y= rlang::expr(!!compartment), colour=shQuote("Min params")),
size=1.5) +
geom_line(data=solution_ga_newFitness, aes_string(x= "Time", y= rlang::expr(!!compartment),
colour=shQuote("GA new fitness")), size=1.5) +
geom_point(data=observations, aes_string(x="Time", y= rlang::expr(!!compartment),
colour=shQuote("Observations")), size=4)+
labs(title = rlang::expr(!!compartment),
y = ifelse(excreta,"TiO2 (mg)","TiO2 (mg/g tissue)" ),
x = "Time (hours)")+
theme(plot.title = element_text(hjust = 0.5))#+
#scale_y_continuous(trans='log10')
}
plots <- lapply(names(observations)[2:length(observations)],create.plots)
p1 <-  plots[[1]]
p2 <-  plots[[2]]
p3 <-  plots[[3]]
p4 <-  plots[[4]]
p5 <-  plots[[5]]
p6 <-  plots[[6]]
p7 <-  plots[[7]]
p8 <-  plots[[8]]
p9 <-  plots[[9]]
p10 <-  plots[[10]]
gridExtra::grid.arrange(p1,p2,p3,p4,nrow = 2)
gridExtra::grid.arrange(p5,p6,p7,p8,nrow = 2)
gridExtra::grid.arrange(p9,p10,nrow = 2)
fitted_ga_newFitness <-  create.position(grouping_ga_newFitness)$fitted
nm_optimizer_ga_newFitness<- dfoptim::nmk(par = fitted_ga_newFitness, fn = obj.func,
control = list(maxfeval=MAX, trace=T), y_init = y_init,
time_points = time_points,
excretion_time_points =  excretion_time_points,
sample_time = sample_time,
phys_pars = phys_pars,
position = position_ga_newFitness )
ga_newFitness_params<- exp(nm_optimizer_ga_newFitness$par)
# Create the matrix of the system
A_max <- create_ODE_matrix(phys_pars = phys_pars, fit_pars = max_params,  position = position_max)
A_min <- create_ODE_matrix(phys_pars = phys_pars, fit_pars = min_params,  position = position_min)
A_ga_newFitness <- create_ODE_matrix(phys_pars = phys_pars, fit_pars = ga_newFitness_params,
position = position_ga_newFitness )
# Solve the ODE system using the exponential matrix method
solution_max <-  as.data.frame(solve_exp_matrix(x = A_max, time = sample_time,
y_init = y_init,phys_pars = phys_pars ))
names(solution_max) <- c("Time", "Blood", "Heart", "Lungs", "Liver",  "Spleen",
"Kidneys","Git", "Bone",  "Feces", "Urine")
solution_min <-  as.data.frame(solve_exp_matrix(x = A_min, time = sample_time,
y_init = y_init,phys_pars = phys_pars ))
names(solution_min) <- c("Time", "Blood", "Heart", "Lungs", "Liver",  "Spleen",
"Kidneys","Git", "Bone",  "Feces", "Urine")
solution_ga_newFitness <-  as.data.frame(solve_exp_matrix(x = A_ga_newFitness, time = sample_time,
y_init = y_init,phys_pars = phys_pars ))
names(solution_ga_newFitness) <- c("Time","Blood", "Heart", "Lungs", "Liver", "Spleen",
"Kidneys","Git", "Bone",  "Feces", "Urine")
# Create a single data frame to hold the observation data
observations <- data.frame( Time =c(24,  72, 168, 360, 720), excretion, df)
library(ggplot2)
create.plots <- function(compartment){
excreta <- compartment %in% c("Feces", "Urine")
ggplot(data = solution_max)+
geom_line( aes_string(x= "Time", y= rlang::expr(!!compartment), colour=shQuote("Max params")),
size=1.5) +
geom_line( aes_string(x= "Time", y= rlang::expr(!!compartment), colour=shQuote("Min params")),
size=1.5) +
geom_line(data=solution_ga_newFitness, aes_string(x= "Time", y= rlang::expr(!!compartment),
colour=shQuote("GA new fitness")), size=1.5) +
geom_point(data=observations, aes_string(x="Time", y= rlang::expr(!!compartment),
colour=shQuote("Observations")), size=4)+
labs(title = rlang::expr(!!compartment),
y = ifelse(excreta,"TiO2 (mg)","TiO2 (mg/g tissue)" ),
x = "Time (hours)")+
theme(plot.title = element_text(hjust = 0.5))#+
#scale_y_continuous(trans='log10')
}
plots <- lapply(names(observations)[2:length(observations)],create.plots)
p1 <-  plots[[1]]
p2 <-  plots[[2]]
p3 <-  plots[[3]]
p4 <-  plots[[4]]
p5 <-  plots[[5]]
p6 <-  plots[[6]]
p7 <-  plots[[7]]
p8 <-  plots[[8]]
p9 <-  plots[[9]]
p10 <-  plots[[10]]
gridExtra::grid.arrange(p1,p2,p3,p4,nrow = 2)
gridExtra::grid.arrange(p5,p6,p7,p8,nrow = 2)
gridExtra::grid.arrange(p9,p10,nrow = 2)
plot(GA_results)
grouping_ga_newFitness
library(ggplot2)
create.plots <- function(compartment){
excreta <- compartment %in% c("Feces", "Urine")
ggplot(data = solution_max)+
geom_line( aes_string(x= "Time", y= rlang::expr(!!compartment), colour=shQuote("Max params")),
size=1.5) +
geom_line(data=solution_min, aes_string(x= "Time", y= rlang::expr(!!compartment),
colour=shQuote("Min params")), size=1.5) +
geom_line(data=solution_ga_newFitness, aes_string(x= "Time", y= rlang::expr(!!compartment),
colour=shQuote("GA new fitness")), size=1.5) +
geom_point(data=observations, aes_string(x="Time", y= rlang::expr(!!compartment),
colour=shQuote("Observations")), size=4)+
labs(title = rlang::expr(!!compartment),
y = ifelse(excreta,"TiO2 (mg)","TiO2 (mg/g tissue)" ),
x = "Time (hours)")+
theme(plot.title = element_text(hjust = 0.5))+
scale_y_continuous(trans='log10')
}
plots <- lapply(names(observations)[2:length(observations)],create.plots)
p1 <-  plots[[1]]
p2 <-  plots[[2]]
p3 <-  plots[[3]]
p4 <-  plots[[4]]
p5 <-  plots[[5]]
p6 <-  plots[[6]]
p7 <-  plots[[7]]
p8 <-  plots[[8]]
p9 <-  plots[[9]]
p10 <-  plots[[10]]
gridExtra::grid.arrange(p1,p2,p3,p4,nrow = 2)
gridExtra::grid.arrange(p5,p6,p7,p8,nrow = 2)
gridExtra::grid.arrange(p9,p10,nrow = 2)
220/12
200/(220/12)
6.85*220/12
200/30
220/30
210/30
2.4*30
3.2*30
3.7*30
5500*1.5
jaqpotr::login.cred()
dose <- 0.7*230/1000*1000 #mg/kg  mass(g)/1000  1000 to transform to ug
df = data.frame("dose"= dose,
"sim.step" =1,
"sim.start"=0,
"times"=0,
"sim.end"=10)
# ID of the model in Jaqpot
modelID <- "lUP5Nqoa6JOTZG4CQnSJ"
# Acquire model predictions
preds <- jaqpot.predict(df=df, modelID=modelID)
dose <- 0.7*230/1000*1000 #mg/kg  mass(g)/1000  1000 to transform to ug
df = data.frame("dose"= dose,
"sim.step" =1,
"sim.start"=0,
"times"=0,
"sim.end"=10)
# ID of the model in Jaqpot
modelID <- "lUP5Nqoa6JOTZG4CQnSJ"
# Acquire model predictions
preds <- jaqpotr::jaqpot.predict(df=df, modelID=modelID)
preds$predictions
preds <- jaqpotr::jaqpot.predict(df=df, modelID=modelID)
preds
preds$predictions
preds <- jaqpotr::jaqpot.predict(df=df, modelID=modelID)
preds$predictions
preds <- jaqpotr::jaqpot.predict(df=df, modelID=modelID)
preds$predictions
