# observations should be the same.
AICc <- function(k, predictions, observations, n = NULL, times=NULL){
# calculate n in case it is not given
if(is.null(n) & is.null(times)){
n <- 0
for (i in 1:length(observations)) {
n <- n + dim(observations[[i]])[1]
}
}else if(is.null(n) & !is.null(times)){
n <- length(observations) * lengths(times)
}
print(paste0("RSS is: ",RSS(predictions,observations,times)))
AICc <- n*log(RSS(predictions,observations,times)/n) + 2*k + (2*k*(k+1))/(n-k-1)
return(AICc)
}
####################################
#===================================
#  *** MAX PROBLEM ***
#===================================
#####################################
# Nelder-Mead from dfoptim package
y_init <- c(dose, rep(0,19))
time_points <- c(1,3,7, 15, 30)*24 # hours
excretion_time_points <- excretion_time
sample_time <- seq(0, 30*24, 1)
# Initialise vector of physiological parameters
phys_pars <- create.params(compartments,mass)
#---------------------------
# Define fitting parameters
#---------------------------
N_p <-8 #   Number of partition coefficients
N_x <- 8#   Number of permeability coefficients
# Convert the binary encoding to integer
grouping <- c(1:8,1:8)
# Define size of P and X groups
P_groups <- length(unique(grouping[1:N_p]))  # sample size
X_groups <- length(unique(grouping[(N_p+1):(N_p+N_x)]))  # sample size
# set.seed(0)
# Initilise parameter values
fitted <- log(exp(runif(P_groups+X_groups+2, -2,2)))
# Initialise naming vectors
pnames <- rep(NA, P_groups)
xnames <- rep(NA, X_groups)
#Define names for P and X groups
for (i in 1:P_groups){
pnames[i] <- paste0("P", as.character(unique(grouping[1:N_p])[i]))
}
for (j in 1:X_groups){
xnames[j] <- paste0("X", as.character(unique(grouping[(N_p+1):(N_p+N_x)])[j]))
}
# Define the total parameter vector names
names(fitted) <- c(pnames, xnames,"CLE_f", "CLE_u")
# Variable for keeping which value in the fitted params vector corresponds to each coefficient
position = rep(NA, length(grouping))
for (i in 1:(length(position))){
if(i<=8){
position[i] <- which(names(fitted) == paste0("P", as.character(grouping[i])))
}else{
position[i] <- which(names(fitted) == paste0("X", as.character(grouping[i])))
}
}
# Run the Nelder Mead algorithmm to estimate the parameter values
nm_optimizer_max <- dfoptim::nmk(par = fitted, fn = obj.func,
control = list(maxfeval=2000, trace=T), y_init = y_init,
time_points = time_points,
excretion_time_points =  excretion_time_points,
sample_time = sample_time,
phys_pars = phys_pars,
position = position )
# Extract the converged parameter values in the log space
params <- nm_optimizer_max$par
# Create the matrix of the system
A <- create_ODE_matrix(phys_pars = phys_pars, fit_pars =exp(params),  position = position )
# Solve the ODE system using the exponential matrix method
solution <-  solve_exp_matrix(x = A, time = sample_time, y_init = y_init,phys_pars = phys_pars )
observed <- list()
for (i in 1:(length(df))) {
observed[[i]] <- cbind(time_points, df[,i])
}
observed[[i+1]] <-  cbind(excretion_time_points,excretion[,1]) #feces
observed[[i+2]] <-  cbind(excretion_time_points,excretion[,2]) #urine
names(observed) <- c(names(df), names(excretion))
predicted <- solution
names(predicted) <- c("Times",names(df), "Feces", "Urine")
#Obtain AIC for predictions vs observations
AIC_result <- AICc(k =length(params), predictions = predicted, observations = observed)
# GA solves a maximisation problem, and best model gives minimum AIC, so take opposite of AIC
fit_value_max <- AIC_result
print(paste0(" AIC value is ", fit_value_max))
print(paste0("PBPK index is ", nm_optimizer_max$value))
####################################
#===================================
#  *** MIN PROBLEM ***
#===================================
#####################################
#---------------------------
# Define fitting parameters
#---------------------------
# Convert the binary encoding to integer
grouping <- rep(1,16)
# Define size of P and X groups
P_groups <- length(unique(grouping[1:N_p]))  # sample size
X_groups <- length(unique(grouping[(N_p+1):(N_p+N_x)]))  # sample size
# set.seed(0)
# Initilise parameter values
fitted <- log(exp(runif(P_groups+X_groups+2, -2,2)))
# Initialise naming vectors
pnames <- rep(NA, P_groups)
xnames <- rep(NA, X_groups)
#Define names for P and X groups
for (i in 1:P_groups){
pnames[i] <- paste0("P", as.character(unique(grouping[1:N_p])[i]))
}
for (j in 1:X_groups){
xnames[j] <- paste0("X", as.character(unique(grouping[(N_p+1):(N_p+N_x)])[j]))
}
# Define the total parameter vector names
names(fitted) <- c(pnames, xnames,"CLE_f", "CLE_u")
# Variable for keeping which value in the fitted params vector corresponds to each coefficient
position = rep(NA, length(grouping))
for (i in 1:(length(position))){
if(i<=8){
position[i] <- which(names(fitted) == paste0("P", as.character(grouping[i])))
}else{
position[i] <- which(names(fitted) == paste0("X", as.character(grouping[i])))
}
}
# Run the Nelder Mead algorithmm to estimate the parameter values
nm_optimizer_min <- dfoptim::nmk(par = fitted, fn = obj.func,
control = list(maxfeval=100, trace=T), y_init = y_init,
time_points = time_points,
excretion_time_points =  excretion_time_points,
sample_time = sample_time,
phys_pars = phys_pars,
position = position )
# Extract the converged parameter values in the log space
params <- nm_optimizer_min$par
# Create the matrix of the system
A <- create_ODE_matrix(phys_pars = phys_pars, fit_pars =exp(params),  position = position )
# Solve the ODE system using the exponential matrix method
solution <-  solve_exp_matrix(x = A, time = sample_time, y_init = y_init,phys_pars = phys_pars )
observed <- list()
for (i in 1:(length(df))) {
observed[[i]] <- cbind(time_points, df[,i])
}
observed[[i+1]] <-  cbind(excretion_time_points,excretion[,1]) #feces
observed[[i+2]] <-  cbind(excretion_time_points,excretion[,2]) #urine
names(observed) <- c(names(df), names(excretion))
predicted <- solution
names(predicted) <- c("Times",names(df), "Feces", "Urine")
#Obtain AIC for predictions vs observations
AIC_result <- AICc(k =length(params), predictions = predicted, observations = observed)
# GA solves a maximisation problem, and best model gives minimum AIC, so take opposite of AIC
fit_value_min <- AIC_result
print(paste0(" AIC value is ", fit_value_min))
print(paste0("PBPK index is ", nm_optimizer_min$value))
#####################################
#---------------------------
# Define fitting parameters
#---------------------------
#==================
#5.Binary mapping
#==================
# Function for mapping the binary number to integer
# Since with 4 digits numbers from 0-15 can be mapped and here we have 8
# different compartments, every two integers correspond to one compartment
bin2int <- function(bin_seq){
int <- GA::binary2decimal(bin_seq)
if(int == 0 || int == 1){
return(1)
}else if(int == 2 || int == 3){
return(2)
}else if(int == 4 || int == 5){
return(3)
}else if(int == 6 || int == 7){
return(4)
}else if(int == 8 || int == 9){
return(5)
}else if(int == 10 || int == 11){
return(6)
}else if(int == 12 || int == 13){
return(7)
}else if(int == 14 || int == 15){
return(8)
}
}
#=============================
#6. Convert binary to grouping
#=============================
# Function for converting binary into integer (from )
decode_ga_bin <- function(binary_num)
{
# Convert binary encoding to gray encoding to avoid the Hamming cliff problem
gray_num <- GA::gray2binary(binary_num)
gray_num <- binary_num
#Four digit binary encodes up to 15, if we are past 13, assign the value 13
# Partition coefficient grouping
P1 <-bin2int(gray_num[1:4])
P2 <-bin2int(gray_num[5:8])
P3 <-bin2int(gray_num[9:12])
P4 <-bin2int(gray_num[13:16])
P5 <-bin2int(gray_num[17:20])
P6 <-bin2int(gray_num[21:24])
P7 <-bin2int(gray_num[25:28])
P8 <-bin2int(gray_num[29:32])
# Permeability coefficient grouping
X1 <-bin2int(gray_num[33:36])
X2 <-bin2int(gray_num[37:40])
X3 <-bin2int(gray_num[41:44])
X4 <-bin2int(gray_num[45:48])
X5 <-bin2int(gray_num[49:52])
X6 <-bin2int(gray_num[53:56])
X7 <-bin2int(gray_num[57:60])
X8 <-bin2int(gray_num[61:64])
out <- structure(c(P1,P2,P3,P4,P5,P6,P7,P8, X1,X2,X3,X4,X5,
X6,X7,X8), names = c("P1","P2","P3","P4",
"P5","P6", "P7", "P8", "X1",
"X2", "X3", "X4", "X5", "X6", "X7", "X8"))
return(out)
}
# Nelder-Mead from dfoptim package
y_init <- c(dose, rep(0,19))
time_points <- c(1,3,7, 15, 30)*24 # hours
excretion_time_points <- excretion_time
sample_time <- seq(0, 30*24, 1)
# Initialise vector of physiological parameters
phys_pars <- create.params(compartments,mass)
#---------------------------
# Define fitting parameters
#---------------------------
N_p <-8 #   Number of partition coefficients
N_x <- 8#   Number of permeability coefficients
#---------------------------
# Define fitting parameters
#---------------------------
GA_results_bin <- GA_results
# Convert the binary encoding to integer
grouping <- decode_ga_bin(GA_results_bin@solution[1,])
# Define size of P and X groups
P_groups <- length(unique(grouping[1:N_p]))  # sample size
X_groups <- length(unique(grouping[(N_p+1):(N_p+N_x)]))  # sample size
# set.seed(0)
# Initilise parameter values
fitted <- log(exp(runif(P_groups+X_groups+2, -2,2)))
# Initialise naming vectors
pnames <- rep(NA, P_groups)
xnames <- rep(NA, X_groups)
#Define names for P and X groups
for (i in 1:P_groups){
pnames[i] <- paste0("P", as.character(unique(grouping[1:N_p])[i]))
}
for (j in 1:X_groups){
xnames[j] <- paste0("X", as.character(unique(grouping[(N_p+1):(N_p+N_x)])[j]))
}
# Define the total parameter vector names
names(fitted) <- c(pnames, xnames,"CLE_f", "CLE_u")
# Variable for keeping which value in the fitted params vector corresponds to each coefficient
position = rep(NA, length(grouping))
for (i in 1:(length(position))){
if(i<=8){
position[i] <- which(names(fitted) == paste0("P", as.character(grouping[i])))
}else{
position[i] <- which(names(fitted) == paste0("X", as.character(grouping[i])))
}
}
# Run the Nelder Mead algorithmm to estimate the parameter values
nm_optimizer_bin <- dfoptim::nmk(par = fitted, fn = obj.func,
control = list(maxfeval=2000, trace=T), y_init = y_init,
time_points = time_points,
excretion_time_points =  excretion_time_points,
sample_time = sample_time,
phys_pars = phys_pars,
position = position )
# Extract the converged parameter values in the log space
params <- nm_optimizer_bin$par
# Create the matrix of the system
A <- create_ODE_matrix(phys_pars = phys_pars, fit_pars =exp(params),  position = position )
# Solve the ODE system using the exponential matrix method
solution <-  solve_exp_matrix(x = A, time = sample_time, y_init = y_init,phys_pars = phys_pars )
observed <- list()
for (i in 1:(length(df))) {
observed[[i]] <- cbind(time_points, df[,i])
}
observed[[i+1]] <-  cbind(excretion_time_points,excretion[,1]) #feces
observed[[i+2]] <-  cbind(excretion_time_points,excretion[,2]) #urine
names(observed) <- c(names(df), names(excretion))
predicted <- solution
names(predicted) <- c("Times",names(df), "Feces", "Urine")
#Obtain AIC for predictions vs observations
AIC_result <- AICc(k =length(params), predictions = predicted, observations = observed)
# GA solves a maximisation problem, and best model gives minimum AIC, so take opposite of AIC
print(paste0(" AIC value is ", AIC_result))
print(paste0("PBPK index is ", nm_optimizer_bin$value))
#####################################
#---------------------------
# Define fitting parameters
#---------------------------
#==================
#5.Binary mapping
#==================
# Function for mapping the binary number to integer
# Since with 4 digits numbers from 0-15 can be mapped and here we have 8
# different compartments, every two integers correspond to one compartment
bin2int <- function(bin_seq){
int <- GA::binary2decimal(bin_seq)
if(int == 0 || int == 1){
return(1)
}else if(int == 2 || int == 3){
return(2)
}else if(int == 4 || int == 5){
return(3)
}else if(int == 6 || int == 7){
return(4)
}else if(int == 8 || int == 9){
return(5)
}else if(int == 10 || int == 11){
return(6)
}else if(int == 12 || int == 13){
return(7)
}else if(int == 14 || int == 15){
return(8)
}
}
#=============================
#6. Convert binary to grouping
#=============================
# Function for converting binary into integer (from )
decode_ga_bin <- function(binary_num)
{
# Convert binary encoding to gray encoding to avoid the Hamming cliff problem
gray_num <- GA::gray2binary(binary_num)
gray_num <- binary_num
#Four digit binary encodes up to 15, if we are past 13, assign the value 13
# Partition coefficient grouping
P1 <-bin2int(gray_num[1:4])
P2 <-bin2int(gray_num[5:8])
P3 <-bin2int(gray_num[9:12])
P4 <-bin2int(gray_num[13:16])
P5 <-bin2int(gray_num[17:20])
P6 <-bin2int(gray_num[21:24])
P7 <-bin2int(gray_num[25:28])
P8 <-bin2int(gray_num[29:32])
# Permeability coefficient grouping
X1 <-bin2int(gray_num[33:36])
X2 <-bin2int(gray_num[37:40])
X3 <-bin2int(gray_num[41:44])
X4 <-bin2int(gray_num[45:48])
X5 <-bin2int(gray_num[49:52])
X6 <-bin2int(gray_num[53:56])
X7 <-bin2int(gray_num[57:60])
X8 <-bin2int(gray_num[61:64])
out <- structure(c(P1,P2,P3,P4,P5,P6,P7,P8, X1,X2,X3,X4,X5,
X6,X7,X8), names = c("P1","P2","P3","P4",
"P5","P6", "P7", "P8", "X1",
"X2", "X3", "X4", "X5", "X6", "X7", "X8"))
return(out)
}
# Nelder-Mead from dfoptim package
y_init <- c(dose, rep(0,19))
time_points <- c(1,3,7, 15, 30)*24 # hours
excretion_time_points <- excretion_time
sample_time <- seq(0, 30*24, 1)
# Initialise vector of physiological parameters
phys_pars <- create.params(compartments,mass)
#---------------------------
# Define fitting parameters
#---------------------------
N_p <-8 #   Number of partition coefficients
N_x <- 8#   Number of permeability coefficients
#---------------------------
# Define fitting parameters
#---------------------------
GA_results_bin <- GA_results
# Convert the binary encoding to integer
grouping <- decode_ga_bin(GA_results_bin@solution[1,])
# Define size of P and X groups
P_groups <- length(unique(grouping[1:N_p]))  # sample size
X_groups <- length(unique(grouping[(N_p+1):(N_p+N_x)]))  # sample size
# set.seed(0)
# Initilise parameter values
fitted <- log(exp(runif(P_groups+X_groups+2, -2,2)))
# Initialise naming vectors
pnames <- rep(NA, P_groups)
xnames <- rep(NA, X_groups)
#Define names for P and X groups
for (i in 1:P_groups){
pnames[i] <- paste0("P", as.character(unique(grouping[1:N_p])[i]))
}
for (j in 1:X_groups){
xnames[j] <- paste0("X", as.character(unique(grouping[(N_p+1):(N_p+N_x)])[j]))
}
# Define the total parameter vector names
names(fitted) <- c(pnames, xnames,"CLE_f", "CLE_u")
# Variable for keeping which value in the fitted params vector corresponds to each coefficient
position = rep(NA, length(grouping))
for (i in 1:(length(position))){
if(i<=8){
position[i] <- which(names(fitted) == paste0("P", as.character(grouping[i])))
}else{
position[i] <- which(names(fitted) == paste0("X", as.character(grouping[i])))
}
}
# Run the Nelder Mead algorithmm to estimate the parameter values
nm_optimizer_bin <- dfoptim::nmk(par = fitted, fn = obj.func,
control = list(maxfeval=2000, trace=T), y_init = y_init,
time_points = time_points,
excretion_time_points =  excretion_time_points,
sample_time = sample_time,
phys_pars = phys_pars,
position = position )
# Extract the converged parameter values in the log space
params <- nm_optimizer_bin$par
# Create the matrix of the system
A <- create_ODE_matrix(phys_pars = phys_pars, fit_pars =exp(params),  position = position )
# Solve the ODE system using the exponential matrix method
solution <-  solve_exp_matrix(x = A, time = sample_time, y_init = y_init,phys_pars = phys_pars )
observed <- list()
for (i in 1:(length(df))) {
observed[[i]] <- cbind(time_points, df[,i])
}
observed[[i+1]] <-  cbind(excretion_time_points,excretion[,1]) #feces
observed[[i+2]] <-  cbind(excretion_time_points,excretion[,2]) #urine
names(observed) <- c(names(df), names(excretion))
predicted <- solution
names(predicted) <- c("Times",names(df), "Feces", "Urine")
#Obtain AIC for predictions vs observations
AIC_result <- AICc(k =length(params), predictions = predicted, observations = observed)
# GA solves a maximisation problem, and best model gives minimum AIC, so take opposite of AIC
print(paste0(" AIC value is ", AIC_result))
print(paste0("PBPK index is ", nm_optimizer_bin$value))
GA_results@summary
GA_results@fitnessValue
GA_results@solution
grouping
exp(nm_optimizer_bin)
exp(nm_optimizer_bin$value)
exp(nm_optimizer_bin$par)
# Nelder-Mead from dfoptim package
y_init <- c(dose, rep(0,19))
time_points <- c(1,3,7, 15, 30)*24 # hours
excretion_time_points <- excretion_time
sample_time <- seq(0, 30*24, 1)
# Initialise vector of physiological parameters
phys_pars <- create.params(compartments,mass)
#---------------------------
# Define fitting parameters
#---------------------------
N_p <-8 #   Number of partition coefficients
N_x <- 8#   Number of permeability coefficients
#---------------------------
# Define fitting parameters
#---------------------------
GA_results_bin <- GA_results
# Convert the binary encoding to integer
grouping <- decode_ga_bin(GA_results_bin@solution[1,])
# Define size of P and X groups
P_groups <- length(unique(grouping[1:N_p]))  # sample size
X_groups <- length(unique(grouping[(N_p+1):(N_p+N_x)]))  # sample size
# set.seed(0)
# Initilise parameter values
fitted <- log(exp(runif(P_groups+X_groups+2, -2,2)))
# Initialise naming vectors
pnames <- rep(NA, P_groups)
xnames <- rep(NA, X_groups)
#Define names for P and X groups
for (i in 1:P_groups){
pnames[i] <- paste0("P", as.character(unique(grouping[1:N_p])[i]))
}
for (j in 1:X_groups){
xnames[j] <- paste0("X", as.character(unique(grouping[(N_p+1):(N_p+N_x)])[j]))
}
# Define the total parameter vector names
names(fitted) <- c(pnames, xnames,"CLE_f", "CLE_u")
# Variable for keeping which value in the fitted params vector corresponds to each coefficient
position = rep(NA, length(grouping))
for (i in 1:(length(position))){
if(i<=8){
position[i] <- which(names(fitted) == paste0("P", as.character(grouping[i])))
}else{
position[i] <- which(names(fitted) == paste0("X", as.character(grouping[i])))
}
}
# Run the Nelder Mead algorithmm to estimate the parameter values
nm_optimizer_bin <- dfoptim::nmk(par = fitted, fn = obj.func,
control = list(maxfeval=2000, trace=T), y_init = y_init,
time_points = time_points,
excretion_time_points =  excretion_time_points,
sample_time = sample_time,
phys_pars = phys_pars,
position = position )
# Extract the converged parameter values in the log space
params <- nm_optimizer_bin$par
# Create the matrix of the system
A <- create_ODE_matrix(phys_pars = phys_pars, fit_pars =exp(params),  position = position )
# Solve the ODE system using the exponential matrix method
solution <-  solve_exp_matrix(x = A, time = sample_time, y_init = y_init,phys_pars = phys_pars )
observed <- list()
for (i in 1:(length(df))) {
observed[[i]] <- cbind(time_points, df[,i])
}
observed[[i+1]] <-  cbind(excretion_time_points,excretion[,1]) #feces
observed[[i+2]] <-  cbind(excretion_time_points,excretion[,2]) #urine
names(observed) <- c(names(df), names(excretion))
predicted <- solution
names(predicted) <- c("Times",names(df), "Feces", "Urine")
#Obtain AIC for predictions vs observations
AIC_result <- AICc(k =length(params), predictions = predicted, observations = observed)
# GA solves a maximisation problem, and best model gives minimum AIC, so take opposite of AIC
print(paste0(" AIC value is ", AIC_result))
print(paste0("PBPK index is ", nm_optimizer_bin$value))
plot(GA_results)
save.image("~/GitHub/PBPK_Genetic_Algorithm/aic_results.RData")
