#====================
#--------------------------------------------------------------------------------------------------
# "Solve_exp_matrix()" is a function that solves the ODE system using the matrix "x" (which
# contains the coefficients of the system), "time" which is the desired time points to
# be calculated and "y_init" is the initial values of the state variables.
#--------------------------------------------------------------------------------------------------
solve_exp_matrix <- function(x, time, y_init, phys_pars){
with( as.list(phys_pars),{
if(!is.matrix(x)){
stop("x must be a NxN matrix")
}
if(!is.numeric(y_init)){
stop("y_init must be a numeric vector")
}
if(dim(x)[1] != dim(x)[2]){
stop("Matrix x must be NxN")
}
if(dim(x)[1] != length(y_init)){
stop("Dimension of y_init must be equal to dimension of matrix x")
}
y_t  <- matrix(data=NA, nrow = nrow(x), ncol = length(time))
colnames(y_t) <- as.character(time)
y_t[,1] <- y_init
for (t in 2:length(time)) {
solution_t <- expm::expm(x*time[t])%*%y_init
y_t[,t] <- solution_t
}
rownames(y_t) <- rownames(x)
y_t <- data.frame(t(y_t))
# Transform TiO2 masses to concentrations
concentrations <- cbind(time,
(y_t$M_ven + y_t$M_art)/V_blood,
y_t$M_ht/w_ht,
y_t$M_lu/w_lu,
y_t$M_li/w_li,
y_t$M_spl/w_spl,
y_t$M_ki/w_ki,
y_t$M_git/w_git,
y_t$M_bone/w_bone,
y_t$M_feces,
y_t$M_urine)
colnames(concentrations) <- c("Time","C_blood", "C_ht", "C_lu", "C_li",
"C_spl", "C_ki", "C_git", "C_bone", "Feces", "Urine")
return(data.frame(concentrations))
})
}
#===============
#4. PBPK INDEX
#===============
############# Calculate PBPK indices #############
# pbpk.index a function the returns the compartment and consolidated (Total) discrepancy index
# of a PBPK model, given some experimental data. It follows the paper of Krishnan et al.1995.
# observed: list of vectors containing the experimental data
# predictions: list of vectors containing the predicted data
# names of the compartments
pbpk.index <- function(observed, predicted, comp.names =NULL){
# Check if the user provided the correct input format
if (!is.list(observed) || !is.list(predicted)){
stop(" The observations and predictions must be lists")
}
# Check if the user provided equal length lists
if (length(observed) != length(predicted)){
stop(" The observations and predictions must have the same compartments")
}
Ncomp <- length(observed) # Number of compartments
I <- rep(NA, Ncomp) # Compartment discrepancy index
N_obs <- rep(NA, Ncomp) #Number of observations per compartment
#loop over the compartments
for (i in 1:Ncomp){
et <- 0 # errors
Et <-0  # experimental
St <- 0  # simulated
N <- length(observed[[i]]) # number of observations for compartment i
# Check if observations and predictions have equal length
if(N != length(predicted[[i]])){
stop(paste0("Compartment ",i," had different length in the observations and predictions"))
}
N_obs[i] <- N # populate tne N_obs vector
for (j in 1:N){
# sum of absolute squared errors (error = observed - predicted)
et <- et + (abs(observed[[i]][j] - predicted[[i]][j]))^2
# Sum of squared observed values
Et <- Et + (observed[[i]][j])^2
St <- St +  (predicted[[i]][j])^2
}
# root mean square of the absolute error
RMet2 <-sqrt(et/N)
# root mean of the square of observed values
RMEt2 <- sqrt(Et/N)
# root mean of the square of simulated values
RMSt2 <- sqrt(St/N)
I[i] <- ( (RMet2/RMEt2) + (RMet2/RMSt2))/2
}
# Total number of observations
Ntot <- sum(N_obs)
# Initialise the consolidated discrepancy index
Ic <-0
for (i in 1:Ncomp){
Ic <- Ic +  I[i]* N_obs[i]/Ntot
}
# Name the list of compartment discrepancy indices
if ( !is.null(comp.names)){
names(I) <- comp.names
}else if (!is.null(names(observed))){
names(I) <- names(observed)
} else if (!is.null(names(predicted)) && is.null(comp.names) ){
names(I) <- names(predicted)
}
return(Ic)
#return(list(Total_index = Ic, Compartment_index= I))
}
#======================
#5. Objective function
#======================
obj.func <- function(params, ...){
dots <- list(...)
with(as.list(dots),{
# Create the matrix of the system
A <- create_ODE_matrix(phys_pars = phys_pars, fit_pars =exp(params),  position = position )
# Solve the ODE system using the exponential matrix method
solution <-  solve_exp_matrix(x = A, time = sample_time, y_init = y_init,phys_pars = phys_pars )
concentrations <- solution[solution$Time %in% time_points, 2:(dim(solution)[2]-2)]
excr_solution <-  data.frame(solution$Time, solution$Feces, solution$Urine)
excr_solution <- excr_solution[solution$Time %in% excretion_time_points, c(2:3)]
observed <- list()
predicted <- list()
for (i in 1:(length(concentrations))) {
observed[[i]] <- df[,i]
predicted[[i]] <- concentrations[,i]
}
observed[[i+1]] <- excretion[,1] #feces
observed[[i+2]] <- excretion[,2] #urine
predicted[[i+1]] <- excr_solution[,1] #feces
predicted[[i+2]] <- excr_solution[,2] #urine
discrepancy <- pbpk.index(observed, predicted)
return(discrepancy)
})
}
#==================
#5.Binary mapping
#==================
# Function for mapping the binary number to integer
# Since with 4 digits numbers from 0-15 can be mapped and here we have 8
# different compartments, every two integers correspond to one compartment
bin2int <- function(bin_seq){
int <- GA::binary2decimal(bin_seq)
if(int == 0 || int == 1){
return(1)
}else if(int == 2 || int == 3){
return(2)
}else if(int == 4 || int == 5){
return(3)
}else if(int == 6 || int == 7){
return(4)
}else if(int == 8 || int == 9){
return(5)
}else if(int == 10 || int == 11){
return(6)
}else if(int == 12 || int == 13){
return(7)
}else if(int == 14 || int == 15){
return(8)
}
}
#=============================
#6. Convert binary to grouping
#=============================
# Function for converting binary into integer (from )
decode_ga <- function(binary_num)
{
# Convert binary encoding to gray encoding to avoid the Hamming cliff problem
gray_num <- GA::gray2binary(binary_num)
gray_num <- binary_num
#Four digit binary encodes up to 15, if we are past 13, assign the value 13
# Partition coefficient grouping
P1 <-bin2int(gray_num[1:4])
P2 <-bin2int(gray_num[5:8])
P3 <-bin2int(gray_num[9:12])
P4 <-bin2int(gray_num[13:16])
P5 <-bin2int(gray_num[17:20])
P6 <-bin2int(gray_num[21:24])
P7 <-bin2int(gray_num[25:28])
P8 <-bin2int(gray_num[29:32])
# Permeability coefficient grouping
X1 <-bin2int(gray_num[33:36])
X2 <-bin2int(gray_num[37:40])
X3 <-bin2int(gray_num[41:44])
X4 <-bin2int(gray_num[45:48])
X5 <-bin2int(gray_num[49:52])
X6 <-bin2int(gray_num[53:56])
X7 <-bin2int(gray_num[57:60])
X8 <-bin2int(gray_num[61:64])
out <- structure(c(P1,P2,P3,P4,P5,P6,P7,P8, X1,X2,X3,X4,X5,
X6,X7,X8), names = c("P1","P2","P3","P4",
"P5","P6", "P7", "P8", "X1",
"X2", "X3", "X4", "X5", "X6", "X7", "X8"))
return(out)
}
#=====================================
#7. Calculate Residual Sum of Squares
#=====================================
RSS <- function(predictions, observations, times=NULL){
if(!is.list(observations)){
stop("Observations must be given as a list")
}
for (i in 1:length(observations)) {
if(!is.matrix(observations[[i]])){
stop("Each element of observations list must bea 2-column matrix")
}
if(ncol(observations[[i]]) != 2){
stop("Each element of observations must be a 2-column matrix")
}
}
# Checking if all the compartments have been measured for the same time points
for (i in 1:(length(observations)-1)) {
if(all(observations[[i]][,1] == observations[[i+1]][,1])){
different_times <- FALSE
}else{
different_times <- TRUE
break
}
}
if (!is.null(times) & (different_times == TRUE)){
warning("parameter 'times' will not be used because different time vectors have
been detected in the observations provided")
}
predicted <- list()
if(different_times){ # if the data time points for each compartment are different, ignore times parameter and keep all the values from the data
for(i in colnames(predictions)[2:dim(predictions)[2]]){
predicted[[i]] <- predictions[which(predictions$Time %in% observations[[i]][,1]) ,i]
}
}else{ # if the data time points for each compartment are the same, use times parameter and keep data only for these moments
for(i in colnames(predictions)[2:dim(predictions)[2]]){
predicted[[i]] <- predictions[which(predictions$Time %in% times),i]
observations[[i]] <- observations[[i]][which(observations[[i]][,1] %in% times ),]
}
}
observed <- list()
for (i in 1:length(observations)) {
observed[[i]] <- observations[[i]][,2] #drop the column of time for each compartment and keep ony the data
}
res <- list()
for (i in 1:length(observed)) { # loop for each compartment
res[[i]] <- observed[[i]] - predicted[[i]] # calculate the residuals of each compartment and store them to lists
}
names(res) <- names(observed)
return(sum((unlist(res))^2)) # Unlist all residuals and sum their squared values
}
#=================
#8. Calculate AIC
#=================
#=====================
# Akaike information criteria corrected for small sample size
# n = Number of total observations
# k = Number of model parameters
# Observations is a list of lists, each sublist consist of a 2 col-matrix,
# with the first column being time and the second the actual observations.
# Predictions is a dataframe with time as its first column and the rest
# of the columns being the tissues of interest. The names of the predictions and
# observations should be the same.
AICc <- function(k, predictions, observations, n = NULL, times=NULL){
# calculate n in case it is not given
if(is.null(n) & is.null(times)){
n <- 0
for (i in 1:length(observations)) {
n <- n + dim(observations[[i]])[1]
}
}else if(is.null(n) & !is.null(times)){
n <- length(observations) * lengths(times)
}
AICc <- -2*log(RSS(predictions,observations,times)/n) + 2*k + (2*k*(k+1))/(n-k-1)
return(AICc)
}
#==========================
#9. Calculate fitness score
#==========================
ga_fitness <- function(chromosome)
{
# Nelder-Mead from dfoptim package
y_init <- c(dose, rep(0,19))
time_points <- c(1,3,7, 15, 30)*24 # hours
excretion_time_points <- excretion_time
sample_time <- seq(0, 30*24, 1)
# Initialise vector of physiological parameters
phys_pars <- create.params(compartments,mass)
#---------------------------
# Define fitting parameters
#---------------------------
N_p <-8 #   Number of partition coefficients
N_x <- 8#   Number of permeability coefficients
# Convert the binary encoding to integer
grouping <- decode_ga(chromosome)
# Define size of P and X groups
P_groups <- length(unique(grouping[1:N_p]))  # sample size
X_groups <- length(unique(grouping[(N_p+1):(N_p+N_x)]))  # sample size
set.seed(0)
# Initilise parameter values
fitted <- log(exp(runif(P_groups+X_groups+2, -3,3)))
# Initialise naming vectors
pnames <- rep(NA, P_groups)
xnames <- rep(NA, X_groups)
#Define names for P and X groups
for (i in 1:P_groups){
pnames[i] <- paste0("P", as.character(unique(grouping[1:N_p])[i]))
}
for (j in 1:X_groups){
xnames[j] <- paste0("X", as.character(unique(grouping[(N_p+1):(N_p+N_x)])[j]))
}
# Define the total parameter vector names
names(fitted) <- c(pnames, xnames,"CLE_f", "CLE_u")
# Variable for keeping which value in the fitted params vector corresponds to each coefficient
position = rep(NA, length(grouping))
for (i in 1:(length(position))){
if(i<=8){
position[i] <- which(names(fitted) == paste0("P", as.character(grouping[i])))
}else{
position[i] <- which(names(fitted) == paste0("X", as.character(grouping[i])))
}
}
# Run the Nelder Mead algorithmm to estimate the parameter values
nm_optimizer_max <- dfoptim::nmk(par = fitted, fn = obj.func,
control = list(maxfeval=1e+4), y_init = y_init,
time_points = time_points,
excretion_time_points =  excretion_time_points,
sample_time - sample_time,
phys_pars = phys_pars,
position = position )
# Extract the converged parameter values in the log space
params <- nm_optimizer_max$par
# Create the matrix of the system
A <- create_ODE_matrix(phys_pars = phys_pars, fit_pars =exp(params),  position = position )
# Solve the ODE system using the exponential matrix method
solution <-  solve_exp_matrix(x = A, time = sample_time, y_init = y_init,phys_pars = phys_pars )
observed <- list()
for (i in 1:(length(concentrations))) {
observed[[i]] <- cbind(time_points, df[,i])
}
observed[[i+1]] <-  cbind(excretion_time_points,excretion[,1]) #feces
observed[[i+2]] <-  cbind(excretion_time_points,excretion[,2]) #urine
names(observed) <- c(names(df), names(excretion))
predicted <- solution
names(predicted) <- c("Times",names(df), "Feces", "Urine")
#Obtain AIC for predictions vs observations
AIC_result <- AICc(k =length(params), predictions = predicted, observations = observed)
return(list(AIC_result))
}
##############################
#=============================
#  ***  Genetic algorithm  ***
#=============================
##############################
#=======================================================================
#                    Available tuning parameters
#                        (binary encoding)
#=======================================================================
#                            /Selection/
# gabin_lrSelection:Linear-rank selection
# gabin_nlrSelection:Nonlinear-rank selection.
# gabin_rwSelection:Proportional (roulette wheel) selection.
# gabin_tourSelection: (Unbiased) tournament selection
#
#                            /Crossover/
# gabin_spCrossover: Single-point crossover
# gabin_uCrossover: Uniform crossover
#
#                           /Mutation/
# gabin_raMutation: Uniform random mutation
GA_results <- GA::ga(type = "binary", fitness = ga_fitness,
nBits = 4*8*2,
population = "gabin_Population",
selection = "gabin_rwSelection",
crossover = "gabin_spCrossover",
mutation = "gabin_raMutation",
popSize = 16, #the population size.
pcrossover = 0.8, #the probability of crossover between pairs of chromosomes.
pmutation = 0.1, #the probability of mutation in a parent chromosome
elitism = 2, #the number of best fitness individuals to survive at each generation.
maxiter = 30, #the maximum number of iterations to run before the GA search is halted.
run = 5, # the number of consecutive generations without any improvement
#in the best fitness value before the GA is stopped.
keepBest = TRUE, # best solutions at each iteration should be saved in a slot called bestSol.
parallel = TRUE,
monitor ='plot',
seed = 1234)
#==========================
#9. Calculate fitness score
#==========================
ga_fitness <- function(chromosome)
{
# Nelder-Mead from dfoptim package
y_init <- c(dose, rep(0,19))
time_points <- c(1,3,7, 15, 30)*24 # hours
excretion_time_points <- excretion_time
sample_time <- seq(0, 30*24, 1)
# Initialise vector of physiological parameters
phys_pars <- create.params(compartments,mass)
#---------------------------
# Define fitting parameters
#---------------------------
N_p <-8 #   Number of partition coefficients
N_x <- 8#   Number of permeability coefficients
# Convert the binary encoding to integer
grouping <- decode_ga(chromosome)
# Define size of P and X groups
P_groups <- length(unique(grouping[1:N_p]))  # sample size
X_groups <- length(unique(grouping[(N_p+1):(N_p+N_x)]))  # sample size
set.seed(0)
# Initilise parameter values
fitted <- log(exp(runif(P_groups+X_groups+2, -3,3)))
# Initialise naming vectors
pnames <- rep(NA, P_groups)
xnames <- rep(NA, X_groups)
#Define names for P and X groups
for (i in 1:P_groups){
pnames[i] <- paste0("P", as.character(unique(grouping[1:N_p])[i]))
}
for (j in 1:X_groups){
xnames[j] <- paste0("X", as.character(unique(grouping[(N_p+1):(N_p+N_x)])[j]))
}
# Define the total parameter vector names
names(fitted) <- c(pnames, xnames,"CLE_f", "CLE_u")
# Variable for keeping which value in the fitted params vector corresponds to each coefficient
position = rep(NA, length(grouping))
for (i in 1:(length(position))){
if(i<=8){
position[i] <- which(names(fitted) == paste0("P", as.character(grouping[i])))
}else{
position[i] <- which(names(fitted) == paste0("X", as.character(grouping[i])))
}
}
# Run the Nelder Mead algorithmm to estimate the parameter values
nm_optimizer_max <- dfoptim::nmk(par = fitted, fn = obj.func,
control = list(maxfeval=1e+4), y_init = y_init,
time_points = time_points,
excretion_time_points =  excretion_time_points,
sample_time = sample_time,
phys_pars = phys_pars,
position = position )
# Extract the converged parameter values in the log space
params <- nm_optimizer_max$par
# Create the matrix of the system
A <- create_ODE_matrix(phys_pars = phys_pars, fit_pars =exp(params),  position = position )
# Solve the ODE system using the exponential matrix method
solution <-  solve_exp_matrix(x = A, time = sample_time, y_init = y_init,phys_pars = phys_pars )
observed <- list()
for (i in 1:(length(concentrations))) {
observed[[i]] <- cbind(time_points, df[,i])
}
observed[[i+1]] <-  cbind(excretion_time_points,excretion[,1]) #feces
observed[[i+2]] <-  cbind(excretion_time_points,excretion[,2]) #urine
names(observed) <- c(names(df), names(excretion))
predicted <- solution
names(predicted) <- c("Times",names(df), "Feces", "Urine")
#Obtain AIC for predictions vs observations
AIC_result <- AICc(k =length(params), predictions = predicted, observations = observed)
return(list(AIC_result))
}
##############################
#=============================
#  ***  Genetic algorithm  ***
#=============================
##############################
#=======================================================================
#                    Available tuning parameters
#                        (binary encoding)
#=======================================================================
#                            /Selection/
# gabin_lrSelection:Linear-rank selection
# gabin_nlrSelection:Nonlinear-rank selection.
# gabin_rwSelection:Proportional (roulette wheel) selection.
# gabin_tourSelection: (Unbiased) tournament selection
#
#                            /Crossover/
# gabin_spCrossover: Single-point crossover
# gabin_uCrossover: Uniform crossover
#
#                           /Mutation/
# gabin_raMutation: Uniform random mutation
GA_results <- GA::ga(type = "binary", fitness = ga_fitness,
nBits = 4*8*2,
population = "gabin_Population",
selection = "gabin_rwSelection",
crossover = "gabin_spCrossover",
mutation = "gabin_raMutation",
popSize = 6, #the population size.
pcrossover = 0.8, #the probability of crossover between pairs of chromosomes.
pmutation = 0.1, #the probability of mutation in a parent chromosome
elitism = 2, #the number of best fitness individuals to survive at each generation.
maxiter = 10, #the maximum number of iterations to run before the GA search is halted.
run = 5, # the number of consecutive generations without any improvement
#in the best fitness value before the GA is stopped.
keepBest = TRUE, # best solutions at each iteration should be saved in a slot called bestSol.
parallel = TRUE,
monitor ='plot',
seed = 1234)
GA_results <- GA::ga(type = "binary", fitness = ga_fitness,
nBits = 4*8*2,
population = "gabin_Population",
selection = "gabin_rwSelection",
crossover = "gabin_spCrossover",
mutation = "gabin_raMutation",
popSize = 6, #the population size.
pcrossover = 0.8, #the probability of crossover between pairs of chromosomes.
pmutation = 0.1, #the probability of mutation in a parent chromosome
elitism = 2, #the number of best fitness individuals to survive at each generation.
maxiter = 10, #the maximum number of iterations to run before the GA search is halted.
run = 5, # the number of consecutive generations without any improvement
#in the best fitness value before the GA is stopped.
keepBest = TRUE, # best solutions at each iteration should be saved in a slot called bestSol.
parallel = TRUE,
monitor = plot,
seed = 1234)
