Wm_ven=0.01*Vven
Wm_art=0.01*Vart
return(c(
"Q_total"=Q_total, "V_blood"=Total_Blood, "V_ven"=Vven, "V_art"=Vart,
"w_rob"=parameters[1,1], "w_ht"=parameters[2,1], "w_ki"=parameters[3,1], "w_spl"=parameters[5,1], "w_lu"=parameters[6,1], "w_li"=parameters[7,1], "w_bone"=parameters[9,1], "w_git"=parameters[13,1],
"V_tis_rob"=parameters[1,2], "V_tis_ht"=parameters[2,2], "V_tis_ki"=parameters[3,2], "V_tis_spl"=parameters[5,2], "V_tis_lu"=parameters[6,2], "V_tis_li"=parameters[7,2], "V_tis_bone"=parameters[9,2], "V_tis_git"=parameters[13,2],
"V_cap_rob"=parameters[1,3], "V_cap_ht"=parameters[2,3], "V_cap_ki"=parameters[3,3], "V_cap_spl"=parameters[5,3], "V_cap_lu"=parameters[6,3], "V_cap_li"=parameters[7,3], "V_cap_bone"=parameters[9,3], "V_cap_git"=parameters[13,3],
"Q_rob"=parameters[1,4], "Q_ht"=parameters[2,4], "Q_ki"=parameters[3,4], "Q_spl"=parameters[5,4], "Q_lu"=parameters[6,4], "Q_li"=parameters[7,4], "Q_bone"=parameters[9,4], "Q_git"=parameters[13,4]
))
}
# Physiological parameters units
# V_blood, V_ven, V_art (ml): Volume of total blood, venous blood and arterial blood
# w_i (g):                    mass of tissue or organ "i"
# V_tis_i (ml):                volume of tissue or organ "i"
# V_cap_i (ml):                volume of capillary blood in tissue "i"
# Q_i, Q_total (ml/h):        regional blood flow of tissue or organ "i"
#=======================
#2. Create system matrix
#=======================
#--------------------------------------------------------------------------------------------------
# "create_ODE_matrix()" creates the matrix with the coefficients of the state variables of the
# desired ODE system. It takes as input the values of parameters and returns the matrix.
#--------------------------------------------------------------------------------------------------
create_ODE_matrix <- function(phys_pars, fit_pars, position){
with( as.list(phys_pars),{
#============================
#Indexing of state variables
#============================
# x1 <- M_ven
# x2 <- M_art
# Capillaries       | Tissue
# x3 <- M_cap_ht    | x4 <- M_ht
# x5 <- M_cap_lu    | x6 <- M_lu
# x7 <- M_cap_li    | x8 <- M_li
# x9 <- M_cap_spl   | x10 <- M_spl
# x11 <- M_cap_ki   | x12 <- M_ki
# x13 <- M_cap_git  | x14 <- M_git
# x15 <- M_cap_bone | x16 <- M_bone
# x17 <- M_cap_rob  | x18 <- M_rob
# x19 <- M_feces    | x20 <- M_urine
# Matrix "A" contains the coefficients of the ODEs system of the PBPK. The ODEs system contains 20 variables,
# so the dimensions of matrix A are 20x20. Each row of the matrix represents the differential equation of each
# state variable x_i and each column represents the value of the coefficient of each state variable x_j in ODE
# of each x_i. The indexing of state variables is analytically presented in the table "Indexing of state variables".
# Numbering of parameters
#1:ht, 2:lu, 3:li, 4:spl, 5:ki, 6:git, 7:bone, 8:rob
P_ht <- fit_pars[position[1]]
P_lu <- fit_pars[position[2]]
P_li <- fit_pars[position[3]]
P_spl <- fit_pars[position[4]]
P_ki <- fit_pars[position[5]]
P_git <- fit_pars[position[6]]
P_bone <- fit_pars[position[7]]
P_rob <- fit_pars[position[8]]
x_ht <- fit_pars[position[9]]
x_lu <- fit_pars[position[10]]
x_li <- fit_pars[position[11]]
x_spl <- fit_pars[position[12]]
x_ki <- fit_pars[position[13]]
x_git <- fit_pars[position[14]]
x_bone <- fit_pars[position[15]]
x_rob <- fit_pars[position[16]]
CLE_f <- fit_pars[length(fit_pars)-1]
CLE_u <- fit_pars[length(fit_pars)]
A <- matrix(c(rep(0,20^2)),
nrow = 20)
rownames(A) <- c("M_ven", "M_art",
"M_cap_ht" ,"M_ht",
"M_cap_lu" ,"M_lu",
"M_cap_li" ,"M_li",
"M_cap_spl" ,"M_spl",
"M_cap_ki" ,"M_ki",
"M_cap_git" ,"M_git",
"M_cap_bone" ,"M_bone",
"M_cap_rob" ,"M_rob",
"M_feces"  ,"M_urine")
colnames(A) <- rownames(A)
#Venous
A[1,1]<- -Q_total/V_ven; A[1,3]<-Q_ht/V_cap_ht; A[1,7]<-(Q_spl+Q_li)/V_cap_li; A[1,11]<-Q_ki/V_cap_ki; A[1,13]<-Q_git/V_cap_git;
A[1,15]<-Q_bone/V_cap_bone; A[1,17]<-Q_rob/V_cap_rob
#Arterial
A[2,2]<- -Q_total/V_art; A[2,5]<-Q_total/V_cap_lu
#Heart - Capillaries
A[3,2]<- Q_ht/V_art; A[3,3] <- -Q_ht/V_cap_ht -x_ht*Q_ht/V_cap_ht; A[3,4]<- x_ht*Q_ht/(w_ht*P_ht)
#Heart - Tissue
A[4,3]<- x_ht*Q_ht/V_cap_ht; A[4,4] <- - x_ht*Q_ht/(w_ht*P_ht)
#Lungs- Capillaries
A[5,1] <- Q_total/V_ven; A[5,5] <- -(Q_total/V_cap_lu + x_lu*Q_total/V_cap_lu); A[5,6] <- x_lu*Q_total/(w_lu*P_lu)
#Lungs - Tissue
A[6,5] <- x_lu*Q_total/V_cap_lu; A[6,6] <- -x_lu*Q_total/(w_lu*P_lu)
#Liver - capillaries
A[7,2] <- Q_li/V_art; A[7,7]<- -Q_li/V_cap_li - Q_spl/V_cap_li - x_li*Q_li/V_cap_li;
A[7,8] <- x_li*Q_li/(w_li*P_li); A[7,9] <- Q_spl/V_cap_spl
#Liver - Tissue
A[8,7]<-x_li*Q_li/V_cap_li; A[8,8]<- - x_li*Q_li/(w_li*P_li)
#Spleen - Capillaries
A[9,2] <- Q_spl/V_art; A[9,9]<- -Q_spl/V_cap_spl - x_spl*Q_spl/V_cap_spl; A[9,10] <- x_spl*Q_spl/(w_spl*P_spl)
#Spleen - Tissue
A[10,9] <- x_spl*Q_spl/V_cap_spl; A[10,10]<- -x_spl*Q_spl/(w_spl*P_spl)
# Kidneys - Capillaries
A[11,2] <- Q_ki/V_art; A[11,11] <- -Q_ki/V_cap_ki -x_ki*Q_ki/V_cap_ki; A[11,12] <- x_ki*Q_ki/(w_ki*P_ki)
#Kidneys -Tissue
A[12,11] <- x_ki*Q_ki/V_cap_ki; A[12,12] <- - x_ki*Q_ki/(w_ki*P_ki) -CLE_u
#Git - Capillaries
A[13,2] <- Q_git/V_art; A[13,13] <- - Q_git/V_cap_git - x_git*Q_git/V_cap_git; A[13,14] <- x_git*Q_git/(w_git*P_git)
#Git - Tissue
A[14,13] <- x_git*Q_git/V_cap_git; A[14,14] <- - x_git*Q_git/(w_git*P_git) - CLE_f
#Bone - Capillaries
A[15,2] <- Q_bone/V_art; A[15,15]<- -Q_bone/V_cap_bone -x_bone*Q_bone/V_cap_bone; A[15,16] <- x_bone*Q_bone/(w_bone*P_bone)
#Bone - Tissue
A[16,15] <- x_bone*Q_bone/V_cap_bone; A[16,16] <- - x_bone*Q_bone/(w_bone*P_bone)
#RoB - Capillaries
A[17,2] <- Q_rob/V_art; A[17,17] <- - Q_rob/V_cap_rob - x_rob*Q_rob/V_cap_rob; A[17,18] <- x_rob*Q_rob/(w_rob*P_rob)
#RoB - Tissue
A[18,17] <- x_rob*Q_rob/V_cap_rob; A[18,18] <- - x_rob*Q_rob/(w_rob*P_rob)
#Feces
A[19,14] <- CLE_f
#Urine
A[20,12] <- CLE_u
return(A)
})
}
#====================
#3. Matrix exponent
#====================
#--------------------------------------------------------------------------------------------------
# "Solve_exp_matrix()" is a function that solves the ODE system using the matrix "x" (which
# contains the coefficients of the system), "time" which is the desired time points to
# be calculated and "y_init" is the initial values of the state variables.
#--------------------------------------------------------------------------------------------------
solve_exp_matrix <- function(x, time, y_init, phys_pars){
with( as.list(phys_pars),{
if(!is.matrix(x)){
stop("x must be a NxN matrix")
}
if(!is.numeric(y_init)){
stop("y_init must be a numeric vector")
}
if(dim(x)[1] != dim(x)[2]){
stop("Matrix x must be NxN")
}
if(dim(x)[1] != length(y_init)){
stop("Dimension of y_init must be equal to dimension of matrix x")
}
y_t  <- matrix(data=NA, nrow = nrow(x), ncol = length(time))
colnames(y_t) <- as.character(time)
y_t[,1] <- y_init
for (t in 2:length(time)) {
solution_t <- expm::expm(x*time[t])%*%y_init
y_t[,t] <- solution_t
}
rownames(y_t) <- rownames(x)
y_t <- data.frame(t(y_t))
# Transform TiO2 masses to concentrations
concentrations <- cbind(time,
(y_t$M_ven + y_t$M_art)/V_blood,
y_t$M_ht/w_ht,
y_t$M_lu/w_lu,
y_t$M_li/w_li,
y_t$M_spl/w_spl,
y_t$M_ki/w_ki,
y_t$M_git/w_git,
y_t$M_bone/w_bone,
y_t$M_feces,
y_t$M_urine)
colnames(concentrations) <- c("Time","C_blood", "C_ht", "C_lu", "C_li",
"C_spl", "C_ki", "C_git", "C_bone", "Feces", "Urine")
return(data.frame(concentrations))
})
}
#===============
#4. PBPK INDEX
#===============
############# Calculate PBPK indices #############
# pbpk.index a function the returns the compartment and consolidated (Total) discrepancy index
# of a PBPK model, given some experimental data. It follows the paper of Krishnan et al.1995.
# observed: list of vectors containing the experimental data
# predictions: list of vectors containing the predicted data
# names of the compartments
pbpk.index <- function(observed, predicted, comp.names =NULL){
# Check if the user provided the correct input format
if (!is.list(observed) || !is.list(predicted)){
stop(" The observations and predictions must be lists")
}
# Check if the user provided equal length lists
if (length(observed) != length(predicted)){
stop(" The observations and predictions must have the same compartments")
}
Ncomp <- length(observed) # Number of compartments
I <- rep(NA, Ncomp) # Compartment discrepancy index
N_obs <- rep(NA, Ncomp) #Number of observations per compartment
#loop over the compartments
for (i in 1:Ncomp){
et <- 0 # errors
Et <-0  # experimental
St <- 0  # simulated
N <- length(observed[[i]]) # number of observations for compartment i
# Check if observations and predictions have equal length
if(N != length(predicted[[i]])){
stop(paste0("Compartment ",i," had different length in the observations and predictions"))
}
N_obs[i] <- N # populate tne N_obs vector
for (j in 1:N){
# sum of absolute squared errors (error = observed - predicted)
et <- et + (abs(observed[[i]][j] - predicted[[i]][j]))^2
# Sum of squared observed values
Et <- Et + (observed[[i]][j])^2
St <- St +  (predicted[[i]][j])^2
}
# root mean square of the absolute error
RMet2 <-sqrt(et/N)
# root mean of the square of observed values
RMEt2 <- sqrt(Et/N)
# root mean of the square of simulated values
RMSt2 <- sqrt(St/N)
I[i] <- ( (RMet2/RMEt2) + (RMet2/RMSt2))/2
}
# Total number of observations
Ntot <- sum(N_obs)
# Initialise the consolidated discrepancy index
Ic <-0
for (i in 1:Ncomp){
Ic <- Ic +  I[i]* N_obs[i]/Ntot
}
# Name the list of compartment discrepancy indices
if ( !is.null(comp.names)){
names(I) <- comp.names
}else if (!is.null(names(observed))){
names(I) <- names(observed)
} else if (!is.null(names(predicted)) && is.null(comp.names) ){
names(I) <- names(predicted)
}
return(Ic)
#return(list(Total_index = Ic, Compartment_index= I))
}
#======================
#5. Objective function
#======================
obj.func <- function(params, ...){
dots <- list(...)
with(as.list(dots),{
# Create the matrix of the system
A <- create_ODE_matrix(phys_pars = phys_pars, fit_pars =exp(params),  position = position )
# Solve the ODE system using the exponential matrix method
solution <-  solve_exp_matrix(x = A, time = sample_time, y_init = y_init,phys_pars = phys_pars )
concentrations <- solution[solution$Time %in% time_points, 2:(dim(solution)[2]-2)]
excr_solution <-  data.frame(solution$Time, solution$Feces, solution$Urine)
excr_solution <- excr_solution[solution$Time %in% excretion_time_points, c(2:3)]
observed <- list()
predicted <- list()
for (i in 1:(length(concentrations))) {
observed[[i]] <- df[,i]
predicted[[i]] <- concentrations[,i]
}
observed[[i+1]] <- excretion[,1] #feces
observed[[i+2]] <- excretion[,2] #urine
predicted[[i+1]] <- excr_solution[,1] #feces
predicted[[i+2]] <- excr_solution[,2] #urine
discrepancy <- pbpk.index(observed, predicted)
return(discrepancy)
})
}
#==================
#5.Binary mapping
#==================
# Function for mapping the binary number to integer
# Since with 4 digits numbers from 0-15 can be mapped and here we have 8
# different compartments, every two integers correspond to one compartment
bin2int <- function(bin_seq){
int <- GA::binary2decimal(bin_seq)
if(int == 0 || int == 1){
return(1)
}else if(int == 2 || int == 3){
return(2)
}else if(int == 4 || int == 5){
return(3)
}else if(int == 6 || int == 7){
return(4)
}else if(int == 8 || int == 9){
return(5)
}else if(int == 10 || int == 11){
return(6)
}else if(int == 12 || int == 13){
return(7)
}else if(int == 14 || int == 15){
return(8)
}
}
#=============================
#6. Convert binary to grouping
#=============================
# Function for converting binary into integer (from )
decode_ga <- function(binary_num)
{
# Convert binary encoding to gray encoding to avoid the Hamming cliff problem
gray_num <- GA::gray2binary(binary_num)
gray_num <- binary_num
#Four digit binary encodes up to 15, if we are past 13, assign the value 13
# Partition coefficient grouping
P1 <-bin2int(gray_num[1:4])
P2 <-bin2int(gray_num[5:8])
P3 <-bin2int(gray_num[9:12])
P4 <-bin2int(gray_num[13:16])
P5 <-bin2int(gray_num[17:20])
P6 <-bin2int(gray_num[21:24])
P7 <-bin2int(gray_num[25:28])
P8 <-bin2int(gray_num[29:32])
# Permeability coefficient grouping
X1 <-bin2int(gray_num[33:36])
X2 <-bin2int(gray_num[37:40])
X3 <-bin2int(gray_num[41:44])
X4 <-bin2int(gray_num[45:48])
X5 <-bin2int(gray_num[49:52])
X6 <-bin2int(gray_num[53:56])
X7 <-bin2int(gray_num[57:60])
X8 <-bin2int(gray_num[61:64])
out <- structure(c(P1,P2,P3,P4,P5,P6,P7,P8, X1,X2,X3,X4,X5,
X6,X7,X8), names = c("P1","P2","P3","P4",
"P5","P6", "P7", "P8", "X1",
"X2", "X3", "X4", "X5", "X6", "X7", "X8"))
return(out)
}
#=====================================
#7. Calculate Residual Sum of Squares
#=====================================
RSS <- function(predictions, observations, times=NULL){
if(!is.list(observations)){
stop("Observations must be given as a list")
}
for (i in 1:length(observations)) {
if(!is.matrix(observations[[i]])){
stop("Each element of observations list must bea 2-column matrix")
}
if(ncol(observations[[i]]) != 2){
stop("Each element of observations must be a 2-column matrix")
}
}
# Checking if all the compartments have been measured for the same time points
for (i in 1:(length(observations)-1)) {
if(all(observations[[i]][,1] == observations[[i+1]][,1])){
different_times <- FALSE
}else{
different_times <- TRUE
break
}
}
if (!is.null(times) & (different_times == TRUE)){
warning("parameter 'times' will not be used because different time vectors have
been detected in the observations provided")
}
predicted <- list()
if(different_times){ # if the data time points for each compartment are different, ignore times parameter and keep all the values from the data
for(i in colnames(predictions)[2:dim(predictions)[2]]){
predicted[[i]] <- predictions[which(predictions$Time %in% observations[[i]][,1]) ,i]
}
}else{ # if the data time points for each compartment are the same, use times parameter and keep data only for these moments
for(i in colnames(predictions)[2:dim(predictions)[2]]){
predicted[[i]] <- predictions[which(predictions$Time %in% times),i]
observations[[i]] <- observations[[i]][which(observations[[i]][,1] %in% times ),]
}
}
observed <- list()
for (i in 1:length(observations)) {
observed[[i]] <- observations[[i]][,2] #drop the column of time for each compartment and keep ony the data
}
res <- list()
for (i in 1:length(observed)) { # loop for each compartment
res[[i]] <- observed[[i]] - predicted[[i]] # calculate the residuals of each compartment and store them to lists
}
names(res) <- names(observed)
return(sum((unlist(res))^2)) # Unlist all residuals and sum their squared values
}
#=================
#8. Calculate AIC
#=================
#=====================
# Akaike information criteria corrected for small sample size
# n = Number of total observations
# k = Number of model parameters
# Observations is a list of lists, each sublist consist of a 2 col-matrix,
# with the first column being time and the second the actual observations.
# Predictions is a dataframe with time as its first column and the rest
# of the columns being the tissues of interest. The names of the predictions and
# observations should be the same.
AICc <- function(k, predictions, observations, n = NULL, times=NULL){
# calculate n in case it is not given
if(is.null(n) & is.null(times)){
n <- 0
for (i in 1:length(observations)) {
n <- n + dim(observations[[i]])[1]
}
}else if(is.null(n) & !is.null(times)){
n <- length(observations) * lengths(times)
}
AICc <- -2*log(RSS(predictions,observations,times)/n) + 2*k + (2*k*(k+1))/(n-k-1)
return(AICc)
}
####################################
#===================================
#  ***  Main Function Content
#===================================
#####################################
count = count+1
print(paste0("The current chromosome is chromosome ", count))
# Nelder-Mead from dfoptim package
y_init <- c(dose, rep(0,19))
time_points <- c(1,3,7, 15, 30)*24 # hours
excretion_time_points <- excretion_time
sample_time <- seq(0, 30*24, 1)
# Initialise vector of physiological parameters
phys_pars <- create.params(compartments,mass)
#---------------------------
# Define fitting parameters
#---------------------------
N_p <-8 #   Number of partition coefficients
N_x <- 8#   Number of permeability coefficients
# Convert the binary encoding to integer
grouping <- decode_ga(chromosome)
# Define size of P and X groups
P_groups <- length(unique(grouping[1:N_p]))  # sample size
X_groups <- length(unique(grouping[(N_p+1):(N_p+N_x)]))  # sample size
set.seed(0)
# Initilise parameter values
fitted <- log(exp(runif(P_groups+X_groups+2, -3,3)))
# Initialise naming vectors
pnames <- rep(NA, P_groups)
xnames <- rep(NA, X_groups)
#Define names for P and X groups
for (i in 1:P_groups){
pnames[i] <- paste0("P", as.character(unique(grouping[1:N_p])[i]))
}
for (j in 1:X_groups){
xnames[j] <- paste0("X", as.character(unique(grouping[(N_p+1):(N_p+N_x)])[j]))
}
# Define the total parameter vector names
names(fitted) <- c(pnames, xnames,"CLE_f", "CLE_u")
# Variable for keeping which value in the fitted params vector corresponds to each coefficient
position = rep(NA, length(grouping))
for (i in 1:(length(position))){
if(i<=8){
position[i] <- which(names(fitted) == paste0("P", as.character(grouping[i])))
}else{
position[i] <- which(names(fitted) == paste0("X", as.character(grouping[i])))
}
}
# Run the Nelder Mead algorithmm to estimate the parameter values
nm_optimizer_max <- dfoptim::nmk(par = fitted, fn = obj.func,
control = list(maxfeval=1e+4), y_init = y_init,
time_points = time_points,
excretion_time_points =  excretion_time_points,
sample_time = sample_time,
phys_pars = phys_pars,
position = position )
# Extract the converged parameter values in the log space
params <- nm_optimizer_max$par
# Create the matrix of the system
A <- create_ODE_matrix(phys_pars = phys_pars, fit_pars =exp(params),  position = position )
# Solve the ODE system using the exponential matrix method
solution <-  solve_exp_matrix(x = A, time = sample_time, y_init = y_init,phys_pars = phys_pars )
observed <- list()
for (i in 1:(length(concentrations))) {
observed[[i]] <- cbind(time_points, df[,i])
}
observed[[i+1]] <-  cbind(excretion_time_points,excretion[,1]) #feces
observed[[i+2]] <-  cbind(excretion_time_points,excretion[,2]) #urine
names(observed) <- c(names(df), names(excretion))
predicted <- solution
names(predicted) <- c("Times",names(df), "Feces", "Urine")
#Obtain AIC for predictions vs observations
AIC_result <- AICc(k =length(params), predictions = predicted, observations = observed)
# GA solves a maximisation problem, and best model gives minimum AIC, so take opposite of AIC
fit_value <- -AIC_result
return(list(AIC_result))
}
##############################
#=============================
#  ***  Genetic algorithm  ***
#=============================
##############################
#=======================================================================
#                    Available tuning parameters
#                        (binary encoding)
#=======================================================================
#                            /Selection/
# gabin_lrSelection:Linear-rank selection
# gabin_nlrSelection:Nonlinear-rank selection.
# gabin_rwSelection:Proportional (roulette wheel) selection.
# gabin_tourSelection: (Unbiased) tournament selection
#
#                            /Crossover/
# gabin_spCrossover: Single-point crossover
# gabin_uCrossover: Uniform crossover
#
#                           /Mutation/
# gabin_raMutation: Uniform random mutation
count <- 0
GA_results <- GA::ga(type = "binary", fitness = ga_fitness,
nBits = 4*8*2,
population = "gabin_Population",
selection = "gabin_rwSelection",
crossover = "gabin_spCrossover",
mutation = "gabin_raMutation",
popSize =  22, #the population size.
pcrossover = 0.8, #the probability of crossover between pairs of chromosomes.
pmutation = 0.1, #the probability of mutation in a parent chromosome
elitism = 2, #the number of best fitness individuals to survive at each generation.
maxiter = 100, #the maximum number of iterations to run before the GA search is halted.
run = 5, # the number of consecutive generations without any improvement
#in the best fitness value before the GA is stopped.
keepBest = TRUE, # best solutions at each iteration should be saved in a slot called bestSol.
parallel = TRUE,
seed = 1234)
